<?xml version="1.0" encoding="UTF-8"?>
<!-- $Header: /var/www/viewcvs.gentoo.org/raw_cvs/gentoo/xml/htdocs/doc/pl/articles/lpi-101-fundamentals-p1.xml,v 1.1 2006/08/09 10:47:06 rane Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/pl/articles/lpi-101-fundamentals-p1.xml" lang="pl" disclaimer="articles">
<title>Przygotowanie do egzaminu na certyfikat DPI 101 (wydanie 2), Część 1</title>

<author title="Autor">
  <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<!--<author title="Editor">
  <mail link="curtis119@gentoo.org">M Curtis Napier</mail>
</author>-->
<author title="Tłumaczenie">
  <mail link="mariusz.s.w@gmail.com">Mariusz Wołos</mail>
</author>

<abstract>
W niniejszym wprowadzeniu zostanie przedstawiony bash (standardowa powłoka
Linuksa), pokazane zostanie w jaki sposób w pełni wykorzystać standardowe
polecenia Linuksa takie jak ls, cp i mv, zostaną wytłumaczone węzły oraz twarde
i symboliczne dowiązania i wiele więcej. Zapoznanie się z tym wprowadzeniem
zapewni zdobycie solidnych podstaw Linuksa i pozwoli na naukę podstawowych zadań
związanych z administrowaniem Linuksem.
</abstract>

<!-- Pierwotna wersja tego artykuły była opublikowana w IBM DeveloperWorks i
jest własnością Westtech Information Services. Niniejszy dokument jest
zaktualizowaną wersją oryginalnego dokumentu i zawiera różne udoskonalenia
wprowadzone przez zespół Gentoo Linux Documentation.-->

<version>1.4</version>
<date>2005-10-12</date>

<chapter>
<title>Na początek</title>
<section>
<title>Informacje o tym dokumencie</title>
<body>

<p>
Witamy w "Podstawach Linuksa", pierwszym z czterech materiałów szkoleniowych
będących przygotowaniem do egzaminu 101 Linux Professional Institute. W tym
wprowadzeniu zostanie przedstawiony bash (standardowa powłoka Linuksa), pokazane
zostanie w jaki sposób w pełni wykorzystać standardowe polecenia Linuksa takie
jak ls, cp i mv, zostaną wytłumaczone węzły oraz twarde i symboliczne dowiązania
i wiele więcej. Zapoznanie się z tym wprowadzeniem zapewni zdobycie solidnych
podstaw Linuksa i pozwoli na dalszą naukę podstawowych zadań związanych z
administrowaniem Linuksem. Zapoznanie się z całą serią materiałów szkoleniowych
(w sumie osiem) zapewni wiedzę potrzebną do tego aby zostać Administratorem
Systemu Linux oraz pozwoli przystąpić do pierwszego egzaminu LPIC organizowanego
przez Linux Professional Institute.
</p>

<p>
Niniejsze wprowadzenie (Część 1) jest idealne dla wszystkich początkujących
użytkowników Linuksa lub dla tych, którzy chcą odświeżyć lub utrwalić swoją
wiedzę na temat podstawowych zadań takich jak kopiowanie i przenoszenie plików,
tworzenie dowiązań symbolicznych i  twardych oraz korzystania ze standardowych
poleceń przetwarzających tekst wraz z potokami i przekierowaniami. Przy okazji
można znaleźć tutaj wiele wskazówek, podpowiedzi i trików, co czyni ten
materiał praktycznym i rzeczowym nawet dla osób posiadających już spore
doświadczenie.  Dla początkujacych większość tego materiału będzie czymś
zupełnie nowym, a dla doświadczonych użytkowników Linuksa może okazać się
idealnym sposobem na doszlifowanie swoich umiejętności.
</p>

<p>
Osoby, które poznały pierwsze wydanie tego materiału z innych powodów niż
przygotowanie do egzaminu LPI nie muszą przerabiać niniejszego wstępu. Ci
jednak, którzy planują przystapienie do egzaminu powinni poważnie wziąć pod
uwagę przeczytanie tego skorygowanego wstępu.
</p>

</body>
</section>
<section>
<title>O autorze</title>
<body>

<p>
Daniel Robbins zamieszkujący w Albuquerque, w stanie Nowy Meksyk, jest głównym
architektem dystrybucji Gentoo Linux. Zajmuje się także pisaniem artykułów dla
strefy Linuksa na IBM Developer Works oraz dla Intel Developer Services. Jest
także współautorem kilku książek, wliczając w to Samba Unleashed oraz SUSE Linux
Unleashed. Daniel lubi spędzać czas ze swoją żoną Mary oraz ze swoją córeczką
Hadassah. Można się z nim skontaktować pisząc na adres poczty elektronicznej
drobbins@gentoo.org.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Wprowadzenie do basha</title>
<section>
<title>Powłoka</title>
<body>

<p>
Jeżeli ktoś używał już systemu Linux, pamięta, że po zalogowaniu witany jest
znakiem zachęty, który wygląda mniej więcej tak:
</p>

<pre caption="Znak zachęty">
$
</pre>

<p>
Znak zachęty widziany przez konkretnego użytkownika może być całkiem inny. Może
zawierać nazwę stacji użytkownika, nazwę katalogu bieżącego, albo i jedno i
drugie. Niezależnie jednak od tego jak wygląda znak zachęty można być pewnym
jednej rzeczy. Tego, że program, który wyświetlił znak zachęty nazywany jest
"powłoką" i jest bardzo prawdopodobne, że jest to powłoka zwana <c>bash</c>.
</p>

</body>
</section>
<section>
<title>Czy korzystamy z basha?</title>
<body>

<p>
W celu sprawdzenia czy korzystamy z powłoki <c>bash</c> należy wpisać:
</p>

<pre caption="Zmienna SHELL">
$ <i>echo $SHELL</i>
/bin/bash
</pre>

<p>
Jeżeli wynikiem powyższego polecenia będzie informacja o błędzie, albo będzie
wynikiem różniącym się od pokazanego powyżej, może to oznaczać, że korzystamy z
powłoki innej niż bash. W takim przypadku większość tego wprowadzenia powinna
nadal być przydatna, nie mniej jednak, przez wzgląd na przygotowanie do
egzaminu 101, pomocnym byłoby przejście na powłokę <c>bash</c>.
<!-- (Następny materiał szkoleniowy z tej serii dotyczący podstaw administracji,
opisuje procedurę zmiany powłoki przy wykorzystaniu polecenia <c>chsh</c>.) -->
</p>

</body>
</section>
<section>
<title>Powłoka bash</title>
<body>

<p>
Bash, którego nazwa jest skrótem od "Bourne-again shell", jest standardową
powłoką większości systemów Linuks. Zadaniem powłoki jest słuchanie poleceń
użytkownika, tak aby mógł on komunikować się ze swoim systemem Linuks. Po
zakończeniu wprowadzania poleceń można zakończyć pracę w powłoce poprzez
wylogowanie i wtedy wróci się do znaku zachęty logowania.
</p>

<p>
A tak przy okazji, to wylogować można się poprzez naciśnięcie klawiszy
control-D.
</p>

</body>
</section>
<section>
<title>Korzystanie z "cd"</title>
<body>

<p>
Startowanie ze znakiem zachęty basha nie jest najbardziej ekscytującą rzeczą na
świecie. Zacznijmy więc korzystać z powłoki bash w celu poruszania się po
naszym systemie plików. W linii poleceń wpisujemy (bez <c>$</c>):
</p>

<pre caption="Zmiana katalogu">
$ <i>cd /</i>
</pre>

<p>
Właśnie powiedzieliśmy powłoce, że chcemy pracować w katalogu /, nazywanym
również katalogiem głównym. Wszystkie katalogi w systemie plików tworzą drzewo a
/ jest wierzchołkiem tego drzewa albo jego korzeniem. Polecenie cd zmienia
katalog, w którym aktualnie pracujemy zwanym także katalogiem bieżącym.
</p>

</body>
</section>
<section>
<title>Ścieżki</title>
<body>

<p>
Aby zobaczyć jaki katalog jest katalogiem bieżącym, należy wpisać:
</p>

<pre caption="Wyświetlanie nazwy katalogu bieżącego">
$ <i>pwd</i>
/
</pre>

<p>
W powyższym przykładzie argument / do polecenia <c>cd</c> nazywany jest
<e>ścieżką</e>. Informuje on polecenie cd o tym gdzie chcemy się dostać.
Dokładnie rzecz ujmując argument / jest ścieżką <e>absolutną</e>, co oznacza, że
podaje lokalizację względem katalogu głównego.
</p>

</body>
</section>
<section>
<title>Ścieżki absolutne</title>
<body>

<p>
Oto kilka przykładów ścieżek absolutnych:
</p>

<pre caption="Przykłady ścieżek absolutnych">
/dev
/usr
/usr/bin
/usr/local/bin
</pre>

<p>
Jak widać, jedną wspólną cechą wszystkich ścieżek absolutnych jest to, że
zaczynają się od /. Podając ścieżkę /usr/local/bin wskazujemy poleceniu cd, że
ma najpierw przejść do katalogu /, z niego przejśc do katalogu usr i dalej do
katalogu local i bin. Ścieżki absolutne zawsze zaczynają się od /.
</p>

</body>
</section>
<section>
<title>Ścieżki względne</title>
<body>

<p>
Inny rodzaj ścieżek nazywany jest <e>ścieżkami względnymi</e>. <c>Bash</c>,
<c>cd</c> i inne polecenia zawsze interpretują te ścieżki względem katalogu
bieżącego. Ścieżki względne nigdy nie zaczynają się od /. Czyli, gdybyśmy byli w
katalogu /usr:
</p>

<pre caption="Zmiana katalogu przy użyciu ścieżek względnych">
$ <i>cd /usr</i>
</pre>

<p>
Wtedy, aby przejść do katalogu /usr/local/bin moglibysmy użyć ścieżki
względnej:
</p>

<pre caption="Zmiana katalogu przy użyciu ścieżek względnych">
$ <i>cd local/bin</i>
$ <i>pwd</i>
/usr/local/bin
</pre>

</body>
</section>
<section>
<title>Korzystanie z ..</title>
<body>

<p>
Ścieżki względne mogą również zawierać jeden lub więcej katalogów .. . Katalog
.. jest katalogiem specjalnym, który wskazuje na katalog nadrzędny. Kontynuując
powyższy przykład:
</p>

<pre caption="Korzystanie z  notacji 'katalog nadrzędny'">
$ <i>pwd</i>
/usr/local/bin
$ <i>cd ..</i>
$ <i>pwd</i>
/usr/local
</pre>

<p>
Jak widać, w tej chwili katalogiem bieżącym jest /usr/local. "Cofnęliśmy się" o
jeden katalog względem katalogu bieżącego, w którym wcześniej byliśmy.
</p>

<p>
Dodatkowo symbol .. może zostać dodany do ścieżki względnej, co pozwoli nam
przejść do katalogu równoległego do tego, w którym się właśnie znajdujemy, np:
</p>

<pre caption="Stosowanie notacji katalogu nadrzędnego w ściezkach względnych">
$ <i>pwd</i>
/usr/local
$ <i>cd ../share</i>
$ <i>pwd</i>
/usr/share
</pre>

</body>
</section>
<section>
<title>Przykłady ścieżek względnych</title>
<body>

<p>
Ścieżki względne mogą być dość skomplikowane. Poniżej przedstawiamy kilka
przykładów bez pokazywania jaki jest katalog wynikowy. Spróbujmy zastanowić się
nad tym w jakim katalogu się znajdziemy po wykonaniu poniższych poleceń:
</p>

<pre caption="Przykłady ścieżek absolutnych">
$ <i>cd /bin</i>
$ <i>cd ../usr/share/zoneinfo</i>


$ <i>cd /usr/X11R6/bin</i>
$ <i>cd ../lib/X11</i>


$ <i>cd /usr/bin</i>
$ <i>cd ../bin/../bin</i>
</pre>

<p>
Teraz wykonajmy te polecenia i sprawdźmy czy dobrze odgadliśmy. :)
</p>

</body>
</section>
<section>
<title>Aby zrozumieć</title>
<body>

<p>
Przed zakończeniem omawiania polecenia cd należy jeszcze wspomnieć o kilku
rzeczach. Po pierwsze istnieje jeszcze jeden katalog specjalny o nazwie ., co
oznacza "katalog bieżący". Katalog ten raczej nie jest używany z poleceniem cd,
niemniej jednak często jest używany do uruchamiania programów znajdujących się
w katalogu bieżącym, tak jak to pokazano poniżej:
</p>

<pre caption="Uruchamianie programu z katalogu bieżącego">
$ <i>./myprog</i>
</pre>

<p>
W powyższym przykładzie zostanie uruchomiony program myprog znajdujący się w
katalogu bieżącym.
</p>

</body>
</section>
<section>
<title>cd i katalog domowy</title>
<body>

<p>
Jeśli chcielibyśmy przejść do naszego katalogu macierzystego moglibyśmy wpisać:
</p>

<pre caption="Przejście do katalogu macierzystego">
$ <i>cd</i>
</pre>

<p>
Polecenie cd wpisane bez żadnych argumentów przeniesie nas do naszego katalogu
macierzystego czyli katalogu /root dla administratora lub standardowo do
/home/nazwa_użytkownika dla zwykłego użytkownika. Jednak co robić gdybyśmy
chcieli wskazać plik w naszym katalogu macierzystym? Powiedzmy, że chcielibyśmy
przekazać argument dla programu <c>myprog</c>. Jeżeli plik ten leży w naszym
katalogu macierzystym wtedy moglibyśmy wpisać:
</p>

<pre caption="Uruchomienie programu z katalogu bieżącego">
$ <i>./myprog /home/drobbins/myfile.txt</i>
</pre>

<p>
Stosowanie ścieżki absolutnej nie jest najwygodniejsze. Na szczęście możemy
zastosować znak ~ (tylda), aby osiągnąć ten sam efekt.
</p>

<pre caption="Używanie notacji katalogu macierzystego">
$ <i>./myprog ~/myfile.txt</i>
</pre>

</body>
</section>
<section>
<title>Katalogi macierzyste innych użytkowników</title>
<body>

<p>
Bash rozwinie znak ~ jako wskazanie do naszego katalogu macierzystego, ale
możemy też za pomocą tego znaku wskazać na katalog macierzysty innych
użytkowników. Gdybyśmy przykładowo chcieli wskazać na plik fredsfile.txt
znajdujący się w katalogu macierzystym Freda, moglibyśmy wpisać:
</p>

<pre caption="Przykładowe zastosowanie notacji katalogu macierzystego">
$ <i>./myprog ~fred/fredsfile.txt</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Korzystanie z poleceń Linuksa</title>
<section>
<title>Polecenie ls</title>
<body>

<p>
Omówimy teraz polecenie ls. Prawdopodobnie każdy już spotkał się z tym
poleceniem i wie, że wpisanie go powoduje wyświetlenie listy z zawartością
katalogu bieżącego:
</p>

<pre caption="Wyświetlanie listy plików">
$ <i>cd /usr</i>
$ <i>ls</i>
X11R6      doc         i686-pc-linux-gnu  lib      man          sbin   ssl
bin        gentoo-x86  include            libexec  portage      share  tmp
distfiles  i686-linux  info               local    portage.old  src
</pre>

<p>
Dodając opcję -a możemy zobaczyć wszystkie pliki w katalogu, razem z plikami
ukrytymi, czyli tymi zaczynającymi się od .. Jak widać w poniższym przykładzie
polecenie ls -a pokazuje również specjalne katalogi . oraz ..:
</p>

<pre caption="Wyświetlanie listy plików, łącznie z plikami ukrytymi">
$ <i>ls -a</i>
.      bin        gentoo-x86         include  libexec  portage      share  tmp
..     distfiles  i686-linux         info     local    portage.old  src
X11R6  doc        i686-pc-linux-gnu  lib      man      sbin         ssl
</pre>

</body>
</section>
<section>
<title>Wyświetlanie szczegółowej listy</title>
<body>

<p>
Przy pomocy polecenia <c>ls</c> można wskazać na jeden lub więcej plików bądź
katalogów. Jeżeli zostanie wskazany plik, wtedy polecenie <c>ls</c> wyświetli
tylko ten plik. Jeżeli zostanie wskazany katalog, <c>ls</c> wyświetli zawartość tego katalogu. Opcja <c>-l</c> jest bardzo przydatna gdy dodatkowo chcemy
zobaczyć informacje o prawach dostępu, własności, dacie modyfikacji, czy też
o rozmiarze wyświetlonych elementów.
</p>

<p>
W poniższym przykładzie korzystamy z opcji <c>-l</c> w celu wyświetlenia pełnej
informacji o zawartości katalogu /usr.
</p>

<pre caption="Wyświetlanie listy plików z pełną informacją">
$ <i>ls -l /usr</i>
drwxr-xr-x    7 root     root          168 Nov 24 14:02 X11R6
drwxr-xr-x    2 root     root        14576 Dec 27 08:56 bin
drwxr-xr-x    2 root     root         8856 Dec 26 12:47 distfiles
lrwxrwxrwx    1 root     root            9 Dec 22 20:57 doc -&gt; share/doc
drwxr-xr-x   62 root     root         1856 Dec 27 15:54 gentoo-x86
drwxr-xr-x    4 root     root          152 Dec 12 23:10 i686-linux
drwxr-xr-x    4 root     root           96 Nov 24 13:17 i686-pc-linux-gnu
drwxr-xr-x   54 root     root         5992 Dec 24 22:30 include
lrwxrwxrwx    1 root     root           10 Dec 22 20:57 info -&gt; share/info
drwxr-xr-x   28 root     root        13552 Dec 26 00:31 lib
drwxr-xr-x    3 root     root           72 Nov 25 00:34 libexec
drwxr-xr-x    8 root     root          240 Dec 22 20:57 local
lrwxrwxrwx    1 root     root            9 Dec 22 20:57 man -&gt; share/man
lrwxrwxrwx    1 root     root           11 Dec  8 07:59 portage -&gt; gentoo-x86/
drwxr-xr-x   60 root     root         1864 Dec  8 07:55 portage.old
drwxr-xr-x    3 root     root         3096 Dec 22 20:57 sbin
drwxr-xr-x   46 root     root         1144 Dec 24 15:32 share
drwxr-xr-x    8 root     root          328 Dec 26 00:07 src
drwxr-xr-x    6 root     root          176 Nov 24 14:25 ssl
lrwxrwxrwx    1 root     root           10 Dec 22 20:57 tmp -&gt; ../var/tmp
</pre>

<p>
Pierwsza kolumna pokazuje informacje o prawach dostępu do każego elementu na
liście. Za chwilę objaśnimy jak interpretować te informacje. Następna kolumna
to informacja o ilości dowiązań do każdego z elementów na liście. W tej chwili
tylko o tym wspominamy, lecz później wrócimy do  tej danej. Trzecia i czwarta
kolumna pokazuje odpowiednio właściciela i grupę. Piąta kolumna to informacja o
rozmiarze obiektu. Szósta kolumna podaje czas ostatniej modyfikacji inaczej
zwany "mtime". Ostatnia kolumna to nazwa elementu. Jeżeli plik jest dowiązaniem
symbolicznym to na końcu będzie widać strzałkę -&gt; i ścieżkę, na którą
dowiązanie wskazuje.
</p>

</body>
</section>
<section>
<title>Wyświetlanie katalogów</title>
<body>

<p>
Czasami chcemy wyświetlić informacje o samym katalogu, a nie o jego zawartości.
W takiej sytuacji należy podać opcję <c>-d</c>, dzięki której polecenie ls
wyświetli tylko katalogi, a nie ich zawartość.
</p>

<pre caption="Wydruk katalogów">
$ <i>ls -dl /usr /usr/bin /usr/X11R6/bin ../share</i>
drwxr-xr-x    4 root     root           96 Dec 18 18:17 ../share
drwxr-xr-x   17 root     root          576 Dec 24 09:03 /usr
drwxr-xr-x    2 root     root         3192 Dec 26 12:52 /usr/X11R6/bin
drwxr-xr-x    2 root     root        14576 Dec 27 08:56 /usr/bin
</pre>

</body>
</section>
<section>
<title>Listowanie rekursywne oraz węzły</title>
<body>

<p>
Jak widać, korzystając z opcji <c>-d</c> jesteśmy w stanie wyświetlić tylko
katalogi, stosując jednak opcję <c>-R</c> robimy coś dokładnie odwrotnego: nie
dość, że wyświetlamy zawartość katalogu, to jeszcze dodatkowo rekurencyjnie
wyświetlamy pliki i zawartość katalogów znajdujących się w tym katalogu! Nie
załączamy żadnego przykładu takiego wydruku (ponieważ zazwyczaj taki wydruk
jest bardzo długi), ale można samemu spróbować wykonać polecenie <c>ls -R</c> i
<c>ls -Rl</c>, aby sprawdzić jak wygląda efekt tych poleceń.
</p>

<p>
Na koniec powiemy o opcji <c>-i</c>, która jest wykorzystywana do wyświetlania
numeru i-węzła obiektu:
</p>

<pre caption="Wyświetlanie i-węzła">
$ <i>ls -i /usr</i>
   1409 X11R6        314258 i686-linux           43090 libexec        13394 sbin
   1417 bin            1513 i686-pc-linux-gnu     5120 local          13408 share
   8316 distfiles      1517 include                776 man            23779 src
     43 doc            1386 info                 93892 portage        36737 ssl
  70744 gentoo-x86     1585 lib                   5132 portage.old      784 tmp
</pre>

</body>
</section>
<section>
<title>Zrozumieć i-węzły</title>
<body>

<p>
Do każdego obiektu w systemie plików przypisany jest unikatowy indeks zwany
numerem <c>i-węzła</c>. Może się to wydawać banalne, nie mniej jednak
zrozumienie i-węzłów jest kluczowym dla zrozumienia wielu operacji na systemie
plików. Rozważając na przykład dowiązania . oraz .., które występują w każdym
katalogu. Żeby zrozumieć czym jest katalog .. spójrzmy najpierw na numer i-węzła
katalogu /usr/local:
</p>

<pre caption="Wyświetlanie numeru i-węzła katalogu">
$ <i>ls -id /usr/local</i>
   5120 /usr/local
</pre>

<p>
Katalog /usr/local posiada numer i-węzła 5120. Sprawdźmy teraz jaki jest numer
i-węzła katalogu /usr/local/bin/..:
</p>

<pre caption="Wyświetlanie numeru i-węzła katalogu">
$ <i>ls -id /usr/local/bin/..</i>
   5120 /usr/local/bin/..
</pre>

<p>
Jak widać katalog /usr/local/bin/.. ma taki sam numer i-węzła jak katalog
/usr/local! Oto jak dochodzimy do ładu z tą szokującą rewelacją. Wcześniej
uważaliśmy, że /usr/local to katalog. Teraz odkryliśmy, że tak na prawdę
katalogiem jest i-węzeł o numerze 5120 oraz, że dwa wpisy katalogów (zwanych
dowiązaniami) wskazują na właśnie ten i-węzeł. Zarówno /usr/local jak i
/usr/local/bin/.. są dowiązaniami do i-węzła 5120. I-węzeł 5120 istnieje
fizycznie tylko w jednym miescu na dysku, a wiele elementów na niego wskazuje.
Fizycznym wpisem na dysku jest i-węzeł 5120.
</p>

<p>
Aby dowiedzieć się ile tak naprawdę elementów wskazuje na i-węzeł 5120, należy
wydać polecenie <c>ls -ld</c>:
</p>

<pre caption="Wyświetlanie ilości dowiązań do i-węzłą">
$ <i>ls -dl /usr/local</i>
drwxr-xr-x    8 root     root          240 Dec 22 20:57 /usr/local
</pre>

<p>
Patrząc na drugą kolumnę od lewej zobaczymy, że katalog /usr/local (numer
i-węzła 5120) jest wskazywany osiem razy. Oto ściezki, które wskazują na ten
i-węzeł w moim systemie plików:
</p>

<pre caption="Dowiązania do i-węzła">
/usr/local
/usr/local/.
/usr/local/bin/..
/usr/local/games/..
/usr/local/lib/..
/usr/local/sbin/..
/usr/local/share/..
/usr/local/src/..
</pre>

</body>
</section>
<section>
<title>mkdir</title>
<body>

<p>
Omówimy teraz polecenie mkdir, które służy do tworzenia nowych katalogów.
Poniższy przykład tworzy trzy nowe katalogi, tic, tac i toe, wszystkie w
katalogu /tmp:
</p>

<pre caption="Tworzenie katalogów">
$ <i>cd /tmp</i>
$ <i>mkdir tic tac toe</i>
</pre>

<p>
Domyślnie, polecenie mkdir nie tworzy katalogów nadrzędnych; cała ściezka
katalogów, w której chcemy utworzyć nowy katalog musi istnieć. Czyli, aby
utworzyć katalogi <path>won/der/ful</path>, nalezy wydać trzy osobne polecenia
<c>mkdir</c>:
</p>

<pre caption="Tworzenie katalogów nadrzędnych">
$ <i>mkdir won/der/ful</i>
mkdir: cannot create directory `won/der/ful': No such file or directory
$ <i>mkdir won</i>
$ <i>mkdir won/der</i>
$ <i>mkdir won/der/ful</i>
</pre>

<p>
Polecenie mkdir posiada jednak bardzo przydatną opcję -p, która tworzy
wszystkie nieistniejące wcześniej katalogi nadrzędne, tak jak to widać poniżej:
</p>

<pre caption="Tworzenie katalogów nadrzędnych za pomocą jednego polecenia">
$ <i>mkdir -p easy/as/pie</i>
</pre>

<p>
Jak widać, jest to całkiem proste. Więcej o poleceniu mkdir można dowiedzieć
się wpisując <c>man mkdir</c> i czytając dokumentację systemową. Działa to
prawie dla wszystkich polceń tutaj opisywanych (np. <c>man ls</c>), oprócz
polecenia cd, które jest wbudowanym poleceniem powłoki bash.
</p>

</body>
</section>
<section>
<title>touch</title>
<body>

<p>
Omówimy teraz polecenia <c>cp</c> oraz <c>mv</c>, które służą do kopiowania,
zmiany nazwy oraz przenoszenia plików i katalogów. Aby rozpocząć omawianie tych
poleceń najpierw skorzystamy z polecenia <c>touch</c> w celu utworzenia pliku w
katalogu /tmp:
</p>

<pre caption="Tworzenie pliku">
$ <i>cd /tmp</i>
$ <i>touch copyme</i>
</pre>

<p>
Jeżeli plik istnieje, to polecenie touch aktualizuje parametr "mtime" pliku
(przypomnijmy sobie szóstą kolumnę w wyniku polecenia <c>ls -l</c>). Jeżeli
plik nie istnieje, to zostanie utworzony nowy, pusty plik. Teraz powinniśmy
mieć plik <path>/tmp/copyme</path> o zerowym rozmiarze.
</p>

</body>
</section>
<section>
<title>echo</title>
<body>

<p>
Gdy już mamy plik, dodajmy do niego trochę danych. Można to zrobić za pomocą
polecenia echo, które przyjmowane argumenty wysyła na standardowe wyjście.
Najpierw samo polecenie echo:
</p>

<pre caption="Tworzenie pliku za pomocą polecenia 'echo'">
$ <i>echo "firstfile"</i>
firstfile
</pre>

<p>
Teraz to samo polecenie echo, ale z przekierowaniem wyjścia:
</p>

<pre caption="Korzstanie z przekierowania wyjścia">
$ <i>echo "firstfile" &gt; copyme</i>
</pre>

<p>
Znak większości mówi powłoce aby wyjście polecenia echo zapisać do pliku o
nazwie copyme. Jeżeli plik ten nie istnieje to zostanie utworzony, a jeżeli
istnieje to zostanie nadpisany. Z pomocą polenia <c>ls -l</c> można sprawdzić,
że plik copyme ma rozmiar 10 bajtów ponieważ zawiera słowo firstfile oraz znak
nowej linii:
</p>

<pre caption="Drukowanie informacji o pliku">
$ <i>ls -l copyme</i>
-rw-r--r--    1 root     root           10 Dec 28 14:13 copyme
</pre>

</body>
</section>
<section>
<title>cat oraz cp</title>
<body>

<p>
W celu wyświetlenia na terminalu zawartości pliku należy skorzystać z polecenia
cat:
</p>

<pre caption="Wyświetlanie zawartości pliku">
$ <i>cat copyme</i>
firstfile
</pre>

<p>
Teraz możemy użyć podstawowego polecenia <c>cp</c> w celu utworzenia pliku
copiedme z oryginalnego pliku copyme:
</p>

<pre caption="Kopiowanie pliku">
$ <i>cp copyme copiedme</i>
</pre>

<p>
Gdy się im przyjrzymy, zobaczymy, że faktycznie są to dwa osobne pliki;
posiadają inne numery i-węzła:
</p>

<pre caption="Sprawdzanie numeru i-węzła">
$ <i>ls -i copyme copiedme</i>
  648284 copiedme   650704 copyme
</pre>

</body>
</section>
<section>
<title>mv</title>
<body>

<p>
Teraz użyjemy polecenia mv, aby zmienić nazwę pliku "copiedme" na "movedme".
Numer i-węzła pozostanie taki sam, ale zmieni się nazwa pliku wskazującego na
ten numer i-węzła.
</p>

<pre caption="Zmiana nazwy pliku">
$ <i>mv copiedme movedme</i>
$ <i>ls -i movedme</i>
  648284 movedme
</pre>

<p>
Numer i-węzła pliku pozostanie taki sam tak długo, jak długo pliki będą
znajdowały się w obrębie tego samego systemu plików. Systemy plików zostaną
omówione dokładniej w Części 3 niniejszego wprowadzenia.
</p>

<p>
Jeśli już mówimy o poleceniu mv to powiemy też o innym sposobie wykorzystania
tego polecenia. Polecenie mv oprócz tego, że pozwala na zmianę nazwy pliku, to
służy również do przenoszenia jednego lub większej ilości plików do innej
lokalizacji w hierarchi katalogów. Przykładowo, aby przenieść
<path>/var/tmp/myfile.txt</path> do katalogu <path>/home/drobbins</path> (tak
się składa, że jest to mój kataog macierzysty), mogę wpisać:
</p>

<pre caption="Przenoszenie pliku">
$ <i>mv /var/tmp/myfile.txt /home/drobbins</i>
</pre>

<p>
Po wpisaniu tego polecenia plik myfile.txt zostanie przeniesiony do
<path>/home/drobbins/myfile.txt</path>. Jeżeli <path>/home/drobbins</path> jest
w obrębie innego systemu plików niż <path>/var/tmp</path>, wtedy polecenie mv
zadba o skopiowanie pliku myfile.txt na nowy system plików oraz skasowanie go z
poprzedniego systemu plików. Jak można się domyślać, po skopiowaniu pliku
myfile.txt na inny system plików plik myfile.txt w nowej lokalizacji będzie
posiadał nowy numer i-węzła. Dzieje się tak dlatego, ze każdy system plików
posiada własny, niezależny zakres numerów i-węzłów.
</p>

<p>
Polecenia mv można używać również dla przeniesienia wielu plików do jednego
miejsca w konkretnym katalogu. Przykładowo, w celu przeniesienia pliku
myfile1.txt i myarticle3.txt do /home/drobbins mogę wpisać:
</p>

<pre caption="Przenoszenie wielu plików">
$ <i>mv /var/tmp/myfile1.txt /var/tmp/myarticle3.txt /home/drobbins</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Tworzenie dowiązań i usuwanie plików</title>
<section>
<title>Dowiązania twarde</title>
<body>

<p>
Używaliśmy już pojęcia "dowiązanie" gdy mówilismy o relacji między katalogami
(ich "nazwami"), a i-węzłami (numer indeksu w systemie plików, który zazwyczaj
możemy zignorować). W Linuksie istnieją dwa rodzaje dowiązań. Taki rodzaj
dowiązanie o jakim mówiliśmy wcześniej nazywany jest <e>dowiązaniem
twardym</e>. Konkretny i-węzeł może posiadać dowolną ilość dowiązań twardych i
pozostanie on na systemie plików dopóki nie znikną wszystkie dowiązania twarde
do tego i-węzła. Jeżeli zniknie ostatnie dowiązanie twarde do tego i-węzła i
nie jest on otwarty przez jakiś program to Linux automatycznie go skasuje. Nowe
twarde dowiązania można stworzyć za pomocą polecenia <c>ln</c>:
</p>

<pre caption="Tworzenie dowiązań do plików">
$ <i>cd /tmp</i>
$ <i>touch firstlink</i>
$ <i>ln firstlink secondlink</i>
$ <i>ls -i firstlink secondlink</i>
  15782 firstlink    15782 secondlink
</pre>

<p>
Jak widać, dowiązania twarde działają na poziomie i-węzłów, aby wskazywać na
określony plik. W Linuksie dowiązania twarde posiadają kilka ograniczeń. Po
pierwsze możemy stworzyć dowiązania twarde tylko do plików, a nie do katalogów.
Tak właśnie jest,że pomimo tego, że . oraz .. są systemowo utworzonymi
dowiązaniami twardymi do katalogów to żaden użytkownik (nawet administrator)
nie może sam utworzyć dowiązania twardego do katalogu. Drugim ograniczeniem
dowiązań twardych jest to, że nie mogą one przechodzić pomiędzy różnymi
systemami plików. Oznacza to, że nie można utworzyć dowiązania twardego
/usr/bin/bash do /bin/bash jeżeli katalogi / i /usr znajdują się na innych
systemach plików.
</p>

</body>
</section>
<section>
<title>Dowiązania symboliczne </title>
<body>

<p>
W praktyce częściej stosowane są <e>dowiązania symboliczne</e> niż dowiązania
twarde. Dowiązania symboliczne są to specjalne pliki, które wskazują na inny
plik za pomocą jego nazwy a nie za pomocą i-węzła. Dowiązania symboliczne nie
uniemożliwiają skasowania pliku, na który wskazują; jeżeli plik, na który
wskazują zostanie usunięty wtedy dowiązanie symboliczne będzie po prostu
bezużyteczne, błędne.
</p>

<p>
Dowiązanie symboliczne tworzone jest poprzez dodanie opcji -s do polecenia ln.
</p>

<pre caption="Przeglądanie dowiązań symbolicznych">
$ ln -s secondlink thirdlink
$ ls -l firstlink secondlink thirdlink
-rw-rw-r--    2 agriffis agriffis        0 Dec 31 19:08 firstlink
-rw-rw-r--    2 agriffis agriffis        0 Dec 31 19:08 secondlink
lrwxrwxrwx    1 agriffis agriffis       10 Dec 31 19:39 thirdlink -&gt; secondlink
</pre>

<p>
W wydruku jaki otrzymujemy po wykonaniu polecenia <c>ls -l</c> dowiązania
symbolincze można odróżnić na trzy sposoby. Po pierwsze należy zauważyć, że
pierwsza kolumna zawiera literę l co oznacza dowiązanie symboliczne. Po drugie,
rozmiar dowiązania symbolicznego jest dokładnie taki ile jest znaków w nazwie
obiektu docelowego (w tym przypadku <c>secondlink</c>). Po trzecie, w ostatniej
kolumnie wyświetlana jest nazwa obiektu docelowego, na który wskazuje
dowiązanie poprzedzona znaczkiem -&gt;.
</p>

</body>
</section>
<section>
<title>Dowiązania symboliczne - szczegółowo</title>
<body>

<p>
Generalnie dowiązania symboliczne są bardziej elastyczne od dowiązań twardych.
Dowiązanie symboliczne może zostać utworzone do jakiegokolwiek obiektu
znajdującego się na systemie plików wliczając w to katalogi. Dodatkowo, w
związku z tym, że dowiązania symboliczne opierają się na ścieżce (a nie na
i-węzłach), to nic nie stoi na przeszkodzie, aby stworzyć dowiązanie
symboliczne, które wskazuje na obiekt fizycznie znajdujący się na innym
systemie plików. Niemniej jednak ta cecha może sprawić, że dowiązania
symboliczne będą trochę trudne do zrozumienia.
</p>

<p>
Rozważmy sytuację, w której chcemy utworzyć dowiązanie w /tmp, które wskazuje
na /usr/local/bin. Moglibyśmy zrobić to tak:
</p>

<pre caption="Tworzenie dowiązania do katalogu, sposób pierwszy">
$ <i>ln -s /usr/local/bin bin1</i>
$ <i>ls -l bin1</i>
lrwxrwxrwx    1 root     root           14 Jan  1 15:42 bin1 -&gt; /usr/local/bin
</pre>

<p>
lub tak:
</p>

<pre caption="Tworzenie dowiązania do katalogu, sposób pierwszy">
$ <i>ln -s ../usr/local/bin bin2</i>
$ <i>ls -l bin2</i>
lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -&gt; ../usr/local/bin
</pre>

<p>
Jak widać, obydwa dowiązania symboliczne wskazują na ten sam katalog. Jednak,
jeżeli drugie dowiązanie zostanie kiedykolwiek przeniesione do innego katalogu,
to stanie się dowiązaniem "przerwanym" ze względu na ścieżkę względną:
</p>

<pre caption="Zrywanie dowiązania symbolicznego">
$ <i>ls -l bin2</i>
lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -&gt; ../usr/local/bin
$ <i>mkdir mynewdir</i>
$ <i>mv bin2 mynewdir</i>
$ <i>cd mynewdir</i>
$ <i>cd bin2</i>
bash: cd: bin2: No such file or directory
</pre>

<p>
W związku z tym, że nie istnieje katalog /tmp/usr/local/bin, nie możemy już
zmienić katalogu na bin2; innymi słowy bin2 jest teraz zerwanym dowiązaniem.
</p>

<p>
Z tego właśnie powodu czasami dobrze jest unikać tworzenia dowiązań
symbolicznych ze ścieżką względną. Jest wiele przypadków, kiedy ścieżki
względne są bardzo pomocne. Weźmy pod uwagę przykład gdzie chcemy stworzyć
alternatywną nazwę dla programu w katalogu /usr/bin:
</p>

<pre caption="Przeglądnie informacji o pliku keychain">
# <i>ls -l /usr/bin/keychain</i>
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/bin/keychain
</pre>

<p>
Jako użytkownik root chcemy stworzyć alternatywną nazwę dla pliku "keychain",
np. "kc". W tym przypadku mamy prawa administratora, czego dowodem jest zmiana
znaku zachęty na "#". Potrzebujemy praw dostępu administratora, ponieważ zwykły
użytkownik nie ma praw do tworzenia plików w /usr/bin. Jako administrator
możemy stworzyć alternatywną nazwę dla pliku keychain w następujący sposób:
</p>

<pre caption="Tworzenie dowiązania symbolicznego do keychain">
# <i>cd /usr/bin</i>
# <i>ln -s /usr/bin/keychain kc</i>
# <i>ls -l keychain</i>
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/bin/keychain
# <i>ls -l kc</i>
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -&gt; /usr/bin/keychain
</pre>

<p>
Stworzyliśmy dowiązanie symboliczne o nazwie kc, które wskazuje na plik
/usr/bin/keychain.
</p>

<p>
Takie rozwiązanie działa, ale problemy zaczną się wtedy gdy zdecydujemy
przenieść obydwa pliki, /usr/bin/keychain oraz /usr/bin/kc do katalogu
/usr/local/bin:
</p>

<pre caption="Przenoszenie dowiązania symbolicznego">
# <i>mv /usr/bin/keychain /usr/bin/kc /usr/local/bin</i>
# <i>ls -l /usr/local/bin/keychain</i>
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/local/bin/keychain
# <i>ls -l /usr/local/bin/kc</i>
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -&gt; /usr/bin/keychain
</pre>

<p>
Ponieważ w dowiązaniu zastosowaliśmy ścieżkę bezwzględną, to dowiązanie kc cały
czas wskazuje na plik /usr/bin/keychain, który już nie istnieje ponieważ
przenieśliśmy go do /usr/local/bin.
</p>

<p>
Oznacza to, że kc jest teraz dowiązaniem błędnym. Zarówno ścieżki względne jak
i bezwględne w dowiązaniach symbolicznych posiadają swoje zalety i powinno się
stosować takie rodzaje ścieżek, które są najbardziej odpowiednie dla
konkretnego zastosowania. Najczęściej oba rodzaje ścieżek będą dobre. Poniższy
przykład będzie działał nawet wtedy gdy obydwa pliki zostaną przeniesione:
</p>

<pre caption="Przenoszenie plików z dowiązaniami symbolicznymi">
# <i>cd /usr/bin</i>
# <i>ln -s keychain kc</i>
# <i>ls -l kc</i>
lrwxrwxrwx    1 root     root            8 Jan  5 12:40 kc -&gt; keychain
# <i>mv keychain kc /usr/local/bin</i>
# <i>ls -l /usr/local/bin/keychain</i>
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/local/bin/keychain
# <i>ls -l /usr/local/bin/kc</i>
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -&gt; keychain
</pre>

<p>
Jak widać, możemy uruchomić program keychain poprzez wpisanie
/usr/local/bin/kc. /usr/loca/bin/kc wskazuje na program keychain, który
znajduje się w tym samym katalogu.
</p>

</body>
</section>
<section>
<title>rm</title>
<body>

<p>
Teraz, gdy wiemy już jak używać poleceń cp, mv oraz ln, nadszedł czas aby
nauczyć się jak usuwać obiekty z systemu plików. Dokonuje się tego za pomocą
polecnia <c>rm</c>. W celu usunięcia pliku należy wskazać go po prostu wskazać
w linii poleceń:
</p>

<pre caption="Usuwanie plików">
$ <i>cd /tmp</i>
$ <i>touch file1 file2</i>
$ <i>ls -l file1 file2</i>
-rw-r--r--    1 root     root            0 Jan  1 16:41 file1
-rw-r--r--    1 root     root            0 Jan  1 16:41 file2
$ <i>rm file1 file2</i>
$ <i>ls -l file1 file2</i>
ls: file1: No such file or directory
ls: file2: No such file or directory
</pre>

<p>
Należy pamiętać o tym, że w Linuksie jeżeli dany plik zostanie usunięty za
pomocą polecenia rm to z reguły jest to nieodwracalne. Dlatego też wielu
początkujących administratorów systemu powinno korzystać z opcji -i podczas
usuwania plików. Opcja -i sprawia, że polecenie rm usuwa pliki w trybie
interaktywnym, czyli pyta przed usunięciem pliku. Przykład:
</p>

<pre caption="Usuwanie plików z pytaniem o potwierdzenie">
$ <i>rm -i file1 file2</i>
rm: remove regular empty file `file1'? y
rm: remove regular empty file `file2'? y
</pre>

<p>
W powyższym przykładzie polecenie rm pyta czy na pewno ma usunąć pliki. W
celu ich usunięcia muszę dwukrotnie wpisać "y" i nacisnąć Enter. Gdybym wpisał
"n" plik nie zostałby usunięty. Mógłbym też, jeżeli zrobiłbym naprawdę coś
złego, wcisnąć Control-C, co całkowicie przerwałoby wykonywanie polecenia rm -i,
zanim zdążyłoby ono dokonać potencjalnych zniszczeń w moim systemie.
</p>

<p>
Jeżeli wciąż staramy się przywyknąć do polecenia rm, to pomocnym może być
wpisanie przy pomocy swojego ulubionego edytora tekstu następującej linii do
pliku ~/.bashrc, a następnie wylogowanie się i ponowne zalogowanie. Wtedy za
każdym razem gdy wydane zostanie polecenie rm, powłoka bash automatycznie zmieni
to polecenie w polecenie rm -i. Tym sposobem polecenie rm zawsze będzie działać
w trybie interaktywnym:
</p>

<pre caption="Ustawianie aliasu 'rm -i'">
<i>alias rm="rm -i"</i>
</pre>

</body>
</section>
<section>
<title>rmdir</title>
<body>

<p>
Istnieją dwa sposoby na usunięcie katalogów. Pierwsza to usunięcie wszystkich
obiektów wewnątrz katalogu, a potem za pomocą polecenia <c>rmdir</c> usunięcie
samego katalogu.
</p>

<pre caption="Usuwanie katalogów">
$ <i>mkdir mydir</i>
$ <i>touch mydir/file1</i>
$ <i>rm mydir/file1</i>
$ <i>rmdir mydir</i>
</pre>

<p>
Metoda ta jest powszechnie znana pod nazwą "usuwanie katalogów dla frajerów".
Wszyscy biegli użytkownicy i administratorzy z prawdziwego zdarzenia stosują o
wiele bardziej wygodne polecenie <c>rm -rf</c> opisane poniżej.
</p>

<p>
Najlepszą metodą na usunięcie katalogu jest użycie opcji <e>recursive force</e>
dla polecenia rm, które to opcje sprawiają, że rm usuwa wskazany katalog wraz z
zawartością:
</p>

<pre caption="Usuwanie katalogu z zawartością">
$ <i>rm -rf mydir</i>
</pre>

<p>
Zazwyczaj polecenie rm -rf jest preferowaną metodą usuwania całego drzewa
katalogów. Trzeba być bardzo ostrożnym przy korzystaniu z polecenia rm -rf
ponieważ siła tego narzędzia może być wykorzystana zarówno dla dobrych jak i
złych rzeczy.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Używanie znaków wieloznacznych</title>
<section>
<title>Wprowadzenie do znaków wieloznacznych</title>
<body>

<p>
Podczas codziennego korzystania z Linuksa wielokrotnie spotkamy się z potrzebą
przeprowadzenia jakiejś operacji (np. rm) na wielu plikach jednocześnie. W
takich przypadkach najczęściej jest bardzo niewygodnym wpisywanie wszystkich
plików w linii poleceń:
</p>

<pre caption="Usuwanie wielu plików">
$ <i>rm file1 file2 file3 file4 file5 file6 file7 file8</i>
</pre>

<p>
Z tego powodu, można wykorzystać wbudowaną w Linuksa obsługę znaków
wieloznacznych. Obsługa ta po angielsku nazywana "globbing" (z powodów
historycznych), pozwala na wskazanie kilku plików na raz za pomocą <e>wzorca
wieloznacznego</e>. Bash i inne polecenia Linuksa zinterpretują ten wzorzec
szukacjąc na dysku wszystkich plików, które pasują do tego wzorca. Innymi
słowy, jeżeli mamy pliki file1 do file8 w bieżącym katalogu, wtedy można je
usunąć za pomocą polecenia:
</p>

<pre caption="Usuwanie plików z wykorzystaniem uzupełniania nazw plików przez powłokę">
$ <i>rm file[1-8]</i>
</pre>

<p>
Jeżeli po prostu chcemy usunąć pliki, których nazwa zaczyna się od file jak
również plik, który nazywa się file, to możemy po prostu wpisać:
</p>

<pre caption="Usuwanie plików z wykorzystaniem uzupełniania i symbolu wieloznacznego *">
$ <i>rm file*</i>
</pre>

<p>
Do symbolu wieloznacznego * pasuje dowolny znak lub sekwencja znaków lub nawet
nic, czyli żaden znak. Symbole wieloznaczne wykorzystywane są do wielu więcej
czynności niż tylko do usuwania plików co zostanie omówione w następnym
paragrafie.
</p>

</body>
</section>
<section>
<title>Zrozumieć niedopasowanie</title>
<body>

<p>
Gdybyśmy chcieli wylistować wszystkie obiekty w /etc zaczynające się na literę
g jak również te, które nazywają się g, wydalibyśmy następujące polecenie:
</p>

<pre caption="Przykładowe zastosowanie znaku wieloznaczengo *">
$ <i>ls -d /etc/g*</i>
/etc/gconf  /etc/ggi  /etc/gimp  /etc/gnome  /etc/gnome-vfs-mime-magic  /etc/gpm  /etc/group  /etc/group-
</pre>

<p>
Co by się stało, gdybyśmy podali wzorzec, do którego nie będzie pasował żaden
obiekt w systemie plików? W poniższym przykładzie spróbujemy wydrukować listę
wszystkich plików w /usr/bin, które zaczynają się od asdf i kończą jkl,
włączając w to ewentualny plik asdfjkl:
</p>

<pre caption="Kolejny przykład zastosowania znaku wieloznacznego *">
$ <i>ls -d /usr/bin/asdf*jkl</i>
ls: /usr/bin/asdf*jkl: No such file or directory
</pre>

<p>
Oto co się stało. Zwykle kiedy podajemy wzorzec, pasuje do niego jeden lub
więcej plików, a <e>bash zamienia wzorzec na oddzieloną spacjami listę
wszystkich pasujących do wzorca obiektów</e>. Kiedy jednak nic nie pasuje do
podanego wzorca, wtedy <e>bash pozostawia wszystko, łącznie ze znakami
wieloznacznymi tak jak zostały wpisane</e>. Wtedy polecenie ls nie może znaleźć
pliku o nazwie /usr/bin/asdf*jkl i wyświetli komunikat o błędzie. Zasadą, która
tu zadziałała jest to, że <e>wzorce wieloznaczne są podmieniane tylko wtedy gdy
będzie do nich pasował obiekt systemu plików</e>. W przeciwnyn razie wzorzec
pozostawiany jest dokładnie tak jak został wpisany i jest przekazywany
literalnie.
</p>

</body>
</section>
<section>
<title>Składnia wyrażeń wieloznacznych: * i ?</title>
<body>

<p>
Skoro wiemy już jak działa dopasowanie do wzorca, powinniśmy przyjrzeć sie
składni wyrażeń wieloznacznych. Do rozwijania wyrażeń wieloznacznych stosowane
są znaki specjalne.
</p>

<p>
* zastępuje wiele znaków lub żaden znak. Oznacza to "zamiast * można podstawić
* wszystko łącznie z niczym". Przykład:
</p>

<ul>
  <li>
    /etc/g* pasuje do wszystkich plików w /etc, które zaczynają się od g, lub
    plik o nazwie g
  </li>
  <li>
    /tmp/my*1 pasuje do wszystkich plików w /tmp, które zaczynają się od my i
    kończą się znakiem 1, łącznie z plikiem o nazwie my1
  </li>
</ul>

<p>
Znak ? zastępuje dwolny dokładnie jeden znak. Przykład:
</p>

<ul>
  <li>
    myfile? pasuje do każdego pliku, którego nazwa zaczyna się od slowa myfile,
    po którym występuje jeden dowolny znak.
  </li>
  <li>
    /tmp/notes?txt pasuje zarówno do /tmp/notes.txt jak i do /tmp/notes_txt,
    jeżeli tylko pliki te istnieją.
  </li>
</ul>

</body>
</section>
<section>
<title>Składnia wyrażeń wieloznacznych: []</title>
<body>

<p>
Symbol wieloznaczny [] jest podobny do ?, jest jednak bardziej szczegółowy.
Wykorzystanie tego symbolu wieloznacznego polega na wstawieniu między [ i ]
wszystkich znaków, które chcemy dopasować. Wyrażenie powstałe w wyniku takiej
operacji będzie pasowało do każdego występującego wstawionego znaku. Można
także zastosować znak -, aby określić zakres znaków, jak również można nawet
wstawiać wiele zakresów. Przykłady:
</p>

<ul>
  <li>
    myfile[12] pasuje do myfile1 i do myfile2. Rozwinięcie tego wyrażenia
    wieloznacznego będzie miało miejsce wtedy gdy przynajmniej jeden z plików
    będzie istniał i znajdował się w bieżącym katalogu.
  </li>
  <li>
    [Cc]hange[Ll]og pasuje do Changelog, ChangeLog, changeLog, oraz changelog.
    Jak widać, wyrażenia wieloznaczne budowane za pomocą nawiasów kwadratowych
    mogą być bardzo przydatne przy dopasowaniu wersalików.
  </li>
  <li>
    ls /etc/[0-9]* wydrukuje wszystkie pliki w /etc zaczynające się od cyfry.
  </li>
  <li>
    ls /tmp/[A-Za-z]* wydrukuje wszystkie pliki w /tmp zaczynające się od dużej
    bądź małej litery.
  </li>
</ul>

<p>
Konstrukcja [!] jest podobna do [], z tą tylko różnicą, że poszukiwane będzie
dopasowanie nie do znaków pomiędzy nawiasami, lecz do wszystkich innych znaków,
niż te wyspecyfikowane pomiędzy [! i ]. Przykład:
</p>

<ul>
  <li>
    rm myfile[!9] usunie wszystkie pliki o nazwie myfile zakończonej dowolnym
    znakiem, oprócz pliku myfile9
  </li>
</ul>

</body>
</section>
<section>
<title>Uwagi do znaków wieloznacznych</title>
<body>

<p>
Podczas stosowania znaków wieloznacznych należy uważać na kilka pułapek.  W
związku z tym, że bash traktuje symbole wieloznaczne (?, [, ] oraz *) w
specjalny sposób, należy zwrócić szczególną uwagę na wpisywanie argumentów
poleceń, które zawierają tego rodzaju znaki. Jeżeli np. chcielibyśmy stworzyć
plik, który zawierałby ciąg znaków [fo*], to wykonanie poniższego polecenia
niekoniecznie dałoby spodziewany rezultat:
</p>

<pre caption="Niepoprawne zastosowanie znaków specjalnych">
$ <i>echo [fo]* &gt; /tmp/mynewfile.txt</i>
</pre>

<p>
Jeżeli wzorzec [fo]* pasowałby do jakichkolwiek plików w katalogu bieżącym, to
w pliku /tmp/mynewfile.txt znalazłyby się wszystkie nazwy pasujących do wzorca
plików, a nie, jak się spodziewaliśmy, ciąg znaków [fo]*. Rozwiązanie? Cóż,
jeden sposób, to zamknięcie tego ciągu znaków w pojedynczy cudzysłów, który
sprawi, że bash nie dokona żadnego rozwinięcia symboli wieloznacznych:
</p>

<pre caption="Unieważnianie znaków specjalnych">
$ <i>echo '[fo]*' &gt; /tmp/mynewfile.txt</i>
</pre>

<p>
Przy zastosowaniu takiego sposobu mynewfile.txt będzie zawierał dokładnie ciąg
znaków [fo]*, tak jak tego oczekiwaliśmy. Drugi sposób to zastosowanie sekwencji
ucieczki, w celu przekazania informacji dla powłoki bash, aby traktowała znaki
[, ] oraz * literalnie, a nie jako znaki wieloznaczne:
</p>

<pre caption="Unieważnianie znaków specjalnych, sposób drugi">
$ <i>echo \[fo\]\* &gt; /tmp/mynewfile.txt</i>
</pre>

<p>
Obydwa sposoby (zastosowanie pojedynczego cudzysłowiu i sekwencji ucieczki)
dają ten sam efekt. Skoro już mówimy o unieważnianiu lewym ukośnikiem, to jest
to dobry moment na to aby wspomnieć, że w celu podania znaku \ należy go
również zamknąć w pojedynczy cudzysłów, lub też wpisać \\ (co zostanie
rozwinięte do \).
</p>

<note>
Cudzysłów podwójnego cudzysłowu działa podobnie do pojedynczego, z tą różnicą,
że pozwala on na dokonywanie pewnego zakresu rozwijania symboli specjalnych.
Dlatego też, w przypadku gdy chcemy literalnie przekazać ciąg znaków,
najlepszym do tego narzędziem jest cudzysłów pojedynczy. W celu uzyskania
bardziej wyczerpujących informacji na temat rozwijania symboli wieloznacznych
można wpisać <c>man 7 glob</c>. Więcej informacji na temat stosowania
cudzysłowów nalezy wpisać <c>man 8 glob</c> i przeczytać rozdział QUOTING.
Jeżeli ktoś chce podchodzić do egzaminu LPI, to niech to potraktuje jako
zadanie domowe. :)
</note>

</body>
</section>
</chapter>

<chapter>
<title>Podsumowanie i zasoby informacji</title>
<section>
<title>Podsumowanie</title>
<body>

<p>
Gratulacje; właśnie doszliśmy do końca przeglądu Podstaw Linuksa! Mam nadzieję,
że pomogło to w utrwaleniu podstawowej wiedzy na temat Linuksa. Tematy, które
zostały omówione, wliczając w to podstawy basha, podstawowe polecenia,
dowiązania i symbole wieloznaczne stanowią przygotowanie do następnego
materiału na temat podstaw administrowania, w którym zostaną omówione
zagadnienia takie jak wyrażenia regularne, prawa własności i prawa dostępu,
zarządzanie kontami użytkowników i inne.
</p>

<p>
Poznając dalszy ciąg serii tych materiałów będzie można dojść do pierwszego
poziomu egzaminu LPIC. Jeżeli ktoś jest zainteresowany przystąpieniem do tego
egzaminu to powinien zapoznać się z Zasobami informacji z następnego rozdziału,
które zostały specjalnie wybrane jako rozszerzenie wiadomości omówionych w tym
wprowadzeniu.
</p>

</body>
</section>
<section>
<title>Zasoby informacji</title>
<body>

<p>
W serii artykułów "Bash w przykładach" Daniel omawia w jaki sposób korzystać ze
składni programowania w bashu w celu pisania własnych skryptów. Seria ta
(zwłaszcza część 1 i 2) będzie znakomitym przygotowaniem do egzaminu LPIC
pierwszego poziomu:
</p>

<ul>
  <li>
    <uri link="/doc/pl/articles/bash-by-example-p1.xml">Bash w przykładach,
    Część 1: Podstawy programowania w Bourne-again shell</uri>
  </li>
  <li>
    <uri link="/doc/pl/articles/bash-by-example-p2.xml">Bash w przykładach,
    Część 2: Więcej podstaw programowania w bashu</uri>
  </li>
  <li>
    <uri link="/doc/pl/articles/bash-by-example-p3.xml">Bash w przykładach,
    Część 3: Poznawanie systemu ebuildów</uri>
  </li>
</ul>

<p>
Każdy początkujący, lub średnio zaawansowany użytkownik Linuksa powinien
zapoznać się z Technical FAQ for Linux users, 50 stronicową listą najczęściej
zadawanych pytań dotyczących Linuksa wraz ze szczegółowymi odpowiedziami.
Publikacja ta jest w formacie PDF (Acrobat).
</p>

<p>
Jeżeli ktoś nie zna edytora vi, to powinien zapoznac się z wprowadzeniem do vi
na developerWorks. Artykuł delikatnie, lecz szybko wprowadza czytelnika w
podstawy tego potężnego edytora. Dla wszystkich, którzy nie znają edytora vi
jest to lektura obowiązkowa.
</p>

</body>
</section>
</chapter>
</guide>
