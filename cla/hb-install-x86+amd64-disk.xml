<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/pl/handbook/hb-install-x86+amd64-disk.xml,v 1.5 2007/05/07 23:52:15 rane Exp $ -->

<sections>

<abstract>
Opis tworzenia partycji, na których zostanie zainstalowane Gentoo.
</abstract>

<version>5.1</version>
<date>2007-06-26</date>

<section>
<title>Wprowadzenie do urządzeń blokowych</title>
<subsection>
<title>Urządzenia blokowe</title>
<body>

<p>
Rzućmy okiem na aspekty Gentoo Linux oraz ogólnie Linuksa związane z dyskami.
Omówimy systemy plików, partycje oraz urządzenia blokowe. Następnie
opiszemy proces podziału twardego dysku tak. aby jak najlepiej wykorzystać
dostępne miejsce.
</p>

<p>
Zaczniemy od omówienia <e>urządzeń blokowych</e>. Najpopularniejszym z nich
prawdopodobnie jest <path>/dev/hda</path> reprezentujący w Linuksie pierwszy
napęd IDE. U posiadaczy urządzeń SCSI lub SATA pierwszym takim dyskiem jest
<path>/dev/sda</path>.
</p>

<p>
Urządzenia blokowe stanowią abstrakcyjny interfejs dysków. Programy użytkownika
mogą z nich korzystać nie martwiąc się o to czy napędy są typu IDE, SCSI czy
jakiegoś innego. Przechowywane dane adresuje się jako ciąg 512-bajtowych
bloków.
</p>

</body>
</subsection>
<subsection>
<title>Partycje</title>
<body>

<p>
Teoretycznie przeznaczenie na system całego dysku jest możliwe,
zazwyczaj nie jest to jednak zbyt dobre rozwiązanie. Zamiast tego dzielimy
napęd na mniejsze i dużo łatwiejsze w zarządzaniu urządzenia blokowe.  W
systemach opartych na architekturze <keyval id="arch"/> nazywane są one
<e>partycjami</e>.
</p>

<p>
Wyróżniamy trzy rodzaje partycji: <e>podstawowe</e>, <e>rozszerzone</e> oraz
<e>logiczne</e>.
</p>

<p>
Informacje o partycjach <e>podstawowych</e> przechowywane są w MBR
(master boot record). Jako że jest on bardzo mały (512 bajtów), mieszczą
się w nim dane maksymalnie czterech takich partycji (na przykład,
od <path>/dev/hda1</path> do <path>/dev/hda4</path>).
</p>

<p>
Specjalną odmianą partycji podstawowych są partycje <e>rozszerzone</e>
(również obowiązuje je powyższy limit). Przechowują one wewnątrz siebie kolejne
partycje. W ten sposób można ominąć niewygodną granicę i lepiej zagospodarować
przestrzeń dyskową.
</p>

<p>
Partycje umieszczone i opisane wewnątrz rozszerzonych nazywamy
<e>logicznymi</e>. Dane o nich nie znajdują się w MBR.
</p>

</body>
</subsection>
<subsection>
<title>Zaawansowane metody przechowywania danych</title>
<body>

<p>
Płyty instalacyjne dla architektury <keyval id="arch"/> posiadają obsługę EVMS
oraz LVM2, co znacznie rozszerza możliwości partycjonowania dysków. W
Podręczniku skupimy się na tworzeniu zwykłych partycji, warto jednak wiedzieć,
że możliwe jest korzystanie również z nowocześniejszych rozwiązań.
</p>

</body>
</subsection>
</section>
<section>
<title>Projektowanie schematu podziału</title>
<subsection>
<title>Domyślny schemat podziału</title>
<body>

<p>
Można pominąć samodzielne rozrysowywanie schematu podziału dysku i po prostu
skorzystać z naszego:
</p>

<table>
<tr>
  <th>Partycja</th>
  <th>System plików</th>
  <th>Rozmiar</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Partycja rozruchowa</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partycja wymiany</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>ext3</ti>
  <ti>Pozostałe wolne miejsce</ti>
  <ti>Partycja główna</ti>
</tr>
</table>

<p>
W dalszej części tekstu wyjaśnimy jak wiele i jak dużych partycji należy
utworzyć.  Można pominąć te informacje i przejść bezpośrednio do <uri
link="#fdisk">partycjonowania dysku przy pomocy fdisk</uri>.
</p>

</body>
</subsection>
<subsection>
<title>Jak dużo i o jakim rozmiarze?</title>
<body>

<p>
Ilość partycji ściśle zależy od danego środowiska. Na przykład, jeśli
administrujesz systemem mającym wielu użytkowników, prawdopodobnie uznasz za
stosowne oddzielenie <path>/home</path> aby poprawić bezpieczeństwo i uprościć
tworzenie kopii zapasowych. Jeżeli docelowym zastosowaniem Gentoo jest serwer
poczty, na osobnej partycji powinieneś umieścić <path>/var</path>, gdzie
przechowywane są listy. Dobry wybór systemu plików może znacznie zwiększyć
wydajność. Oddzielenie <path>/opt</path> jest dobrym rozwiązaniem na serwerach
gier, gdyż większość używanego oprogramowania zostanie tam zainstalowana. Powód
jest podobny jak przy <path>/home</path>: bezpieczeństwo i kopie zapasowe.  Na
pewno warto zapewnić dużo wolnego miejsca na <path>/usr</path>, ponieważ będą
tam się znajdowały nie tylko dane wszystkich zainstalowanych pakietów, ale
również ważące 500 MB drzewo Portage i kody źródłowe programów.
</p>

<p>
Jak widać, wiele zależy od oczekiwanego rezultatu. Rozdzielenie partycji ma
wiele zalet:
</p>

<ul>
  <li>
    Daje możliwość wybrania dla poszczególnych partycji najbardziej wydajnego w
    danym zastosowaniu systemu plików.
  </li>
  <li>
    Zapełnienie całego wolnego miejsca na partycji przez wadliwie działający
    program nie będzie miało szkodliwego wpływu na całość systemu.
  </li>
  <li>
    Możliwe będzie skrócenie czasu kontroli systemów plików dzięki
    jednoczesnemu dokonywaniu jej na kilku partycjach (ma to znaczenie
    zwłaszcza na komputerze z wieloma twardymi dyskami).
  </li>
  <li>
    Montując część partycji lub woluminów z opcjami read-only (tylko do
    odczytu), nosuid (ignorowane są bity setuid), noexec (ignorowane są bity
    wykonywalności) itd.  można znacznie poprawić bezpieczeństwo.
  </li>
</ul>

<p>
Niestety zbyt rozbudowany schemat podziału niesie również ze sobą spore
problemy. Źle zaplanowany zaowocuje pustkami na zbyt dużych i ciasnotą na zbyt
małych partycjach.
</p>

<p>
W przykładzie pokażemy partycjonowanie dysku o rozmiarze 20GB wykorzystywanego w
laptopie z zainstalowanym serwerem poczty, stron internetowych oraz
środowiskiem gnome:
</p>

<pre caption="Przykładowy podział dysku">
$ <i>df -h</i>
Filesystem    Type    Size  Used Avail Use% Mounted on
/dev/hda5     ext3    509M  132M  351M  28% /
/dev/hda2     ext3    5.0G  3.0G  1.8G  63% /home
/dev/hda7     ext3    7.9G  6.2G  1.3G  83% /usr
/dev/hda8     ext3   1011M  483M  477M  51% /opt
/dev/hda9     ext3    2.0G  607M  1.3G  32% /var
/dev/hda1     ext2     51M   17M   31M  36% /boot
/dev/hda6     swap    516M   12M  504M   2% &lt;not mounted&gt;
<comment>(Zostało 2GB nie przydzielonego do żadnej partycji miejsca - do wykorzystania w przyszłości)</comment>
</pre>

<p>
<path>/usr</path> jest niemal w pełni zajęty (wykorzystane 83%), ale po
instalacji wszystkich potrzebnych pakietów nie będzie się on zbytnio rozrastał.
Przeznaczenie kilku gigabajtów na <path>/var</path> może wydać się zbyt
rozrzutne. Należy jednak zwrócić uwagę, że Gentoo kompiluje tam domyślnie
wszystkie pakiety. Jeżeli chcemy, aby <path>/var</path> posiadało mniejszy
rozmiar, na przykład 1GB, powinniśmy zmodyfikować zmienną <c>PORTAGE_TMPDIR</c>
w pliku <path>/etc/make.conf</path>, tak aby prowadziła do partycji z
odpowiednią ilością wolnego miejsca do kompilacji ekstremalnie dużych pakietów
takich jak OpenOffice.
</p>

</body>
</subsection>
</section>
<section id="fdisk">
<title>Partycjonowanie dysku przy pomocy fdisk</title>
<subsection>
<body>

<p>
Teraz przedstawimy proces tworzenia partycji wypisanych w naszym przykładowym
schemacie podziału dysku. Oto on:
</p>

<table>
<tr>
  <th>Partycja</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Partycja rozruchowa</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Partycja wymiany</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Partycja główna</ti></tr>
</table>

<p>
Ten schemat oczywiście można (i zwykle należy) zmodyfikować stosownie do
własnych potrzeb.
</p>

</body>
</subsection>
<subsection>
<title>Wyświetlanie aktualnego podziału dysku</title>
<body>

<p>
<c>fdisk</c> to popularne i bardzo wygodne narzędzie służące do partycjonowania
dysków. Zacznijmy od uruchomienia go dla naszego dysku (pokażemy to na
przykładzie <path>/dev/hda</path>):
</p>

<pre caption="Uruchamianie fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Po chwili ukaże się taki znak zachęty <c>fdisk</c>:
</p>

<pre caption="Znak zachęty fdisk">
Command (m for help):
</pre>

<p>
Aby wyświetlić obecną konfigurację partycji wpisujemy <c>p</c>:
</p>

<pre caption="Przykładowa konfiguracja partycji">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help):
</pre>

<p>
Na prezentowanym dysku znajduje się siedem linuksowych systemów plików
(każdy na osobnej partycji, oznaczonej jako "Linux") oraz partycja
wymiany (oznaczona jako "Linux swap").
</p>

</body>
</subsection>
<subsection>
<title>Usuwanie partycji</title>
<body>

<p>
Zacznijmy od usunięcia starych partycji. Służy do tego polecenie <c>d</c> z
odpowiednim dla każdej partycji numerem. Na przykład, aby pozbyć się
<path>/dev/hda1</path> należy wpisać:
</p>

<pre caption="Usuwanie partycji">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Partycja została zaznaczona do usunięcia. Nie będzie więcej pojawiać się po
wpisaniu <c>p</c>, ale pozostanie nienaruszona dopóki zmiany nie zostaną
fizycznie zapisane na dysku. Po popełnieniu błędu przy dzieleniu dysku
wystarczy wpisać <c>q</c> i wcisnąć enter, aby wszystkie dokonane modyfikacje
poszły w niepamięć.
</p>

<p>
Aby pozbyć się wszystkich istniejących partycji wpisujemy <c>p</c>, aby
wyświetlić ich listę, a następnie po kolei kasujemy je poleceniem <c>d</c> z
odpowiednim numerem. Na koniec <c>p</c> powinno dawać następujący rezultat:
</p>

<pre caption="Pusta tablica partycji">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
Kiedy już nasza tymczasowa kopia tablicy partycji będzie pusta możemy rozpocząć
dzielenie dysku. Pokażemy to na przykładzie naszego domyślnego schematu,
który należy odpowiednio zmienić przy każdej instalacji, tak aby możliwie
najlepiej spełniał konkretne przed nim stawiane zadania.
</p>

</body>
</subsection>
<subsection>
<title>Zakładanie partycji rozruchowej</title>
<body>

<p>
Rozpoczniemy od utworzenia niewielkiej partycji rozruchowej. Wpisujemy <c>n</c>,
aby ją założyć, a następnie <c>p</c>, aby nadać jej typ podstawowy i <c>1</c>,
ponieważ będzie to pierwsza taka partycja. Zapytani o pierwszy cylinder wciskamy
enter, a przy pytaniu o ostatni wpisujemy <c>+32M</c>, by nadać jej
rozmiar 32MB.
</p>

<pre caption="Zakładanie partycji rozruchowej">
Command (m for help): <i>n</i>
Command action
  e   extended
  p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1):  <comment>(Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Teraz polecenie <c>p</c> powinno pokazywać taką listę:
</p>

<pre caption="Partycja rozruchowa">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>

<p>
Musimy również oznaczyć naszą partycję jako uruchamialną. W tym celu
skorzystamy z polecenia <c>a</c>. Na kolejnych wydrukach podziału w kolumnie
"Boot" przy naszej partycji pojawi się znak <path>*</path>.
</p>

</body>
</subsection>
<subsection>
<title>Zakładanie partycji wymiany</title>
<body>

<p>
Następnie tworzymy partycję wymiany. Ponownie korzystamy z polecenia <c>n</c>,
potem wpisujemy <c>p</c> (gdyż ma to być partycja podstawowa) i <c>2</c>,
ponieważ będzie ona drugą tego typu. Zapytani o pierwszy cylinder wciskamy
enter, a w odpowiedzi na pytanie o ostatni wpisujemy <c>+512M</c> (aby nadać
partycji rozmiar 512MB). Na koniec wpisujemy <c>t</c> (aby zmienić jej typ),
<c>2</c> (aby wybrać tę, którą właśnie stworzyliśmy) i <c>82</c> (co nada jej
typ "Linux Swap"). Teraz polecenie <c>p</c> powinno pokazywać następującą listę:
</p>

<pre caption="Wydruk podziału po utworzeniu partycji wymiany">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

</body>
</subsection>
<subsection>
<title>Zakładanie partycji głównej</title>
<body>

<p>
Na koniec tworzymy partycję główną. Jeszcze raz posłużymy się poleceniem
<c>n</c>. Zapytani o rodzaj wciskamy <c>p</c> (aby była partycją podstawową),
następnie <c>3</c> (gdyż będzie już trzecią tego typu, czyli w naszym
przypadku <path>/dev/hda3</path>), a na pytanie o pierwszy i ostatni cylinder
wciskamy enter, dzięki czemu zajmie ona całą pozostałą wolną przestrzeń.
Ostatecznie polecenie <c>p</c> powinno pokazać następującą listę:
</p>

<pre caption="Wydruk podziału po utworzeniu partycji głównej">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>

</body>
</subsection>
<subsection>
<title>Zapisywanie podziału partycji</title>
<body>

<p>
Aby zachować ustalony podział i opuścić <c>fdisk</c> należy wpisać <c>w</c>.
</p>

<pre caption="Zachowywanie zmian i zamykanie fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Po utworzeniu partycji można przejść do <uri link="#filesystems">zakładania
systemów plików</uri>.
</p>

</body>
</subsection>
</section>
<section id="filesystems">
<title>Zakładanie systemów plików</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
Po utworzeniu partycji trzeba założyć na nich odpowiednie systemy plików.
Osoby, którym wszystko jedno jaki system plików wybiorą lub te, które są
zadowolone z domyślnych ustawień z Podręcznika mogą przejść do <uri
link="#filesystems-apply">zakładania systemów plików na partycji</uri>.
Pozostali muszą czytać dalej, aby dowiedzieć się więcej na ich temat.
</p>

</body>
</subsection>
<subsection>
<title>Systemy plików?</title>
<body>

<p test="func:keyval('arch')='x86'">
Jądro Linuksa może współpracować z wieloma różnymi systemami plików. W
Podręczniku omówimy te najczęściej używane, czyli ext2, ext3, ReiserFS i JFS.
</p>

<p test="func:keyval('arch')='AMD64'">
Jest dostępnych kilka systemów plików. Kilka z nich jest już stabilnych na
amd64, inne nie są. Następujące systemy plików są stabilne: ext2 i ext3. jfs i
reiserfs mogą działać, ale wciąż wymagają sporo testów. Korzystanie z nich
wciąż wiąże się z pewnym ryzykiem.
</p>

<p>
<b>ext2</b> to sprawdzony i popularny linuksowy system plików,
którego główną wadą jest to, że nie posiada księgowania. Powoduje to, iż jego
regularne kontrole przy starcie systemu bywają długotrwałe. Obecnie istnieją
nowoczesne systemy plików z księgowaniem, które można szybko sprawdzić i to
właśnie te polecamy naszym użytkownikom. Księgowanie zapobiega długotrwałym
kontrolom podczas uruchamiania systemu oraz ewentualnym błędom spójności
danych.
</p>

<p>
<b>ext3</b> to odpowiednik ext2 posiadający księgowanie w trybach full oraz
ordered, dzięki czemu w razie awarii dane odzyskiwane są błyskawicznie. ext3
używa indeksu drzewa HTree, który zapewnia wysoką wydajność w prawie wszystkich
zastosowaniach. W skrócie, ext3 to bardzo dobry i niezawodny system plików.
</p>

<p>
<b>ReiserFS</b> to system plików oparty na drzewie B+, oferujący dużą
wydajność.  Przy wielu małych plikach (poniżej 4k) może być szybszy od ext3
nawet piętnastokrotnie. ReiserFS jest wysoce skalowalny i posiada księgowanie,
Charakteryzuje go niezawodność i użyteczność zarówno na partycjach ogólnego
przeznaczenia jak i w ekstremalnych przypadkach, takich jak ogromne partycje,
operacje na wielu bardzo małych, lub bardzo dużych plikach czy też operacje na
katalogach zawierających dziesiątki tysięcy plików.
</p>

<p>
<b>XFS</b> to system plików z księgowaniem, w pełni wspierany w Gentoo Linux
przez jądro xfs-sources. Jest bardzo funkcjonalny i zoptymalizowany do
skalowalności. Zalecamy go wyłącznie do systemów z nowoczesnymi dyskami SCSI
i/lub ciągłego zapisu danych z nieprzerwanym dostępem zasilania. Ponieważ XFS
przechowuje dużo danych w pamięci RAM, źle zaprojektowane programy (te nie
zachowujące odpowiednich środków ostrożności podczas zapisywania plików na
dysk, których niestety jest sporo) mogą doprowadzić w razie padu systemu do
utraty danych.
</p>

<p>
<b>JFS</b> to bardzo wydajny system plików IBM'a wyposażony w księgowanie.
Jest dość nowy i jest jeszcze za wcześnie by oceniać jego stabilność.
</p>

</body>
</subsection>
<subsection id="filesystems-apply">
<title>Zakładanie systemów plików na partycjach</title>
<body>

<p>
Aby założyć na woluminie lub partycji system plików należy skorzystać z
odpowiednich narzędzi:
</p>

<table>
<tr>
  <th>System plików</th>
  <th>Program do jego zakładania</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
Na przykład, aby założyć ext2 na partycji boot (w naszym przypadku
<path>/dev/hda1</path>) oraz ext3 na partycji root (w naszym przypadku
<path>/dev/hda3</path>) powinieneś wykonać następujące polecenia:
</p>

<pre caption="Zakładanie systemu plików na partycji">
# <i>mke2fs /dev/hda1</i>
# <i>mke2fs -j /dev/hda3</i>
</pre>

<p>
Teraz stwórz systemy plików na swoich partycjach.
</p>

</body>
</subsection>
<subsection>
<title>Aktywacja partycji wymiany</title>
<body>

<p>
Aby utworzyć partycję wymiany, należy skorzystać z programu <c>mkswap</c>.
</p>

<pre caption="Tworzenie partycji wymiany">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
Do aktywowania partycji wymiany używa się programu <c>swapon</c>:
</p>

<pre caption="Aktywacja partycji wymiany">
# <i>swapon /dev/hda2</i>
</pre>

<p>
Teraz tworzymy i aktywujemy partycję wymiany za pomocą wyżej podanych poleceń.
</p>

</body>
</subsection>
</section>
<section>
<title>Montowanie</title>
<body>

<p>
Po założeniu partycji i utworzeniu na nich systemów plików nadszedł czas na ich
zamontowanie. Służy do tego program <c>mount</c>. Należy utworzyć odpowiednie
katalogi dla montowanych partycji. W przykładzie zamontujemy partycję
rozruchową i główną:
</p>

<pre caption="Montowanie partycji">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<note>
Aby przenieść <path>/tmp</path> na osobną partycję, należy po jego zamontowaniu
odpowiednio zmienić prawa dostępu: <c>chmod 1777 /mnt/gentoo/tmp</c>. Dotyczy
to również <path>/var/tmp</path>.
</note>

<p>
Konieczne będzie także zamontowanie systemu plików proc (wirtualny interfejs
jądra) w katalogu <path>/proc</path>, ale najpierw musimy umieścić odpowiednie
pliki na partycjach.
</p>

<p>
Kolejny rozdział to <uri link="?part=1&amp;chap=5">Wypakowywanie plików
instalacyjnych</uri>.
</p>

</body>
</section>
</sections>
