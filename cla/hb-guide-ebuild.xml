<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">
<!-- $Header: /var/www/viewcvs.gentoo.org/raw_cvs/gentoo/xml/htdocs/proj/pl/devrel/handbook/hb-guide-ebuild.xml,v 1.12 2007/05/09 18:08:06 rane Exp $ -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->

<sections>
<version>1.0.3</version>
<date>2007-06-23</date>

<section>
<title>Drzewo Portage</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
Drzewo Portage zwykle znajduje się w katalogu <path>/usr/portage</path> i jest
ułożone w hierarchicznej strukturze, składającej się z katalogów kategorii, w
których znajdują się katalogi pakietów. Oto przykład: plik
<path>util-linux-2.11y.ebuild</path> można znaleźć w katalogu
<path>/usr/portage/sys-apps/util-linux</path>. W tym samym katalogu może
znajdować się kilka innych wersji <c>util-linux</c> razem z wersją
<path>util-linux-2.11y.ebuild</path>. Jest tak, ponieważ <e>wszystkie pliki
ebuild danego pakietu (niezależnie od wersji)</e> mają wspólny katalog
<path>kategoria/pakiet</path> w głównym katalogu <path>/usr/portage</path>.
</p>

</body>
</subsection>
<subsection>
<title>Pobieranie drzewa Portage z CVS</title>
<body>

<p>
W razie jakichkolwiek wątpliwości co do systemu CVS należy przeczytać dokument
<uri link="/doc/pl/cvs-tutorial.xml">Praca z CVS w Gentoo</uri>, gdzie
znajduje się znacznie więcej informacji na ten temat.
</p>

<p>
Drzewo Portage można znaleźć w module <c>gentoo-x86</c> drzewa systemu Gentoo
Linux. Aby pobrać moduł (około 350 megabajtów), najpierw należy skonfigurować
CVS za pomocą powyższego przewodnika, a następnie pobrać moduł
<c>gentoo-x86</c> poleceniem checkout.
</p>

</body>
</subsection>
<subsection>
<title>Co umieszczać (a czego nie) w drzewie Portage</title>
<body>

<p>
Przed napisaniem jakiegokolwiek ebuilda powinniśmy przejrzeć <uri
link="http://bugs.gentoo.org/">bugs.gentoo.org</uri> w poszukiwaniu
niezamieszczonego jeszcze w drzewie Portage pliku ebuild do pakietu, do którego
sami chcieliśmy go pisać. W tym celu należy wejść na stronę <uri
link="http://bugs.gentoo.org/">bugs.gentoo.org</uri>, wybrać "query", jako
produkt (product) wybrać <e>Gentoo Linux</e>, jako składnik (component)
<e>ebuilds</e>. W polu tekstowym powinniśmy wpisać nazwę ebuilda, a jako status
wybrać "NEW", "ASSIGNED", "REOPENED" i "RESOLVED" (to ostatnie jest ważne), a
następnie zatwierdzić zapytanie. Leniwi niech po prostu klikną <uri
link="http://bugs.gentoo.org/query.cgi?product=Gentoo%20Linux&amp;component=Ebuilds&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;bug_status=RESOLVED">tutaj</uri>.
</p>

<p>
Drzewo Portage powinno przede wszystkim być używane do przechowywania plików
<path>.ebuild</path>, a także wszelkich względnie małych plików
pomocniczych, takich jak łatki lub przykładowe pliki konfiguracyjne. Pliki
pomocnicze powinny być umieszczane w katalogu
<path>/usr/portage/kategoria/pakiet/files</path>, aby nie zaśmiecać głównego
katalogu <path>kategoria/pakiet</path>. Wyjątkiem od tej reguły są większe
pliki łatek (zalecamy przyjąć górną granicę rozmiaru pliku na 20KB), które
powinny zostać umieszczone na serwerach lustrzanych Gentoo, aby użytkownicy nie
marnowali przepustowości ani przestrzeni dyskowej. Odradzamy też deweloperom
umieszczanie w CVS plików binarnych (nie-ASCII). Jeśli jednak jest to konieczne
(gdybyśmy na przykład chcieli zamieścić niewielki plik graficzny PNG), należy
dodać go do CVS przy użyciu opcji <c>-kb</c>, tak jak poniżej:
</p>

<pre caption="Dodawanie pliku binarnego do CVS">
# <i>cvs add -kb mojobrazek.png</i>
</pre>

<p>
Opcja <c>-kb</c> instruuje CVS, że plik <path>mojobrazek.png</path> to plik
binarny i powinien być specjalnie traktowany. Nie powinno się na przykład z
oczywistych względów pozwolić na łączenie różnic między dwiema wersjami tego
pliku. Skoro już mowa o łączeniu zmian, pliki poprawek zamieszczane w Portage
nie powinny być kompresowane. Dzięki temu system CVS będzie mógł łączyć zmiany i
poprawnie informować deweloperów o konfliktach.
</p>

<p>
Należy pamiętać, że pakiety, które wysyłamy jako stabilne muszą być
<e>gotowe</e> do <e>natychmiastowego użycia</e> przez końcowych użytkowników.
Musimy upewnić się, że posiadamy dobry zestaw domyślnych ustawień, który
zadowoli większość z nich. Jeśli zaś nasz pakiet nie działa i nie mamy pomysłu
jak sprawić, by działał, warto spojrzeć jak poradzili sobie z nią deweloperzy
innych dystrybucji. Przykładów możemy szukać choćby w repozytoriach <uri
link="http://cvs.mandriva.com/cgi-bin/viewvc.cgi/SPECS/">Mandrivy</uri>, <uri
link="http://www.debian.org/distrib/packages">Debiana</uri> lub <uri
link="http://cvs.fedora.redhat.com/">Fedory</uri>.
</p>

<p>
Wysyłając pliki ebuild do CVS wszyscy deweloperzy powinni używać polecenia
<c>repoman commit</c> zamiast <c>cvs commit</c>. Przed samym zamieszczeniem
należy wykonać polecenie <c>repoman full</c>, aby upewnić się, że o niczym nie
zapominamy.
</p>

</body>
</subsection>
<subsection>
<title>Polityka wysyłania do CVS</title>
<body>

<ul>
  <li>Zawsze należy wykonać polecenie <c>repoman scan</c> przed wysłaniem</li>
  <li>Zawsze należy wykonać polecenie <c>repoman full</c> przed wysłaniem</li>
  <li>
    Zawsze powinniśmy sprawdzić poprawność pliku <path>package.mask</path>
    przed jego wysłaniem przez wykonanie <c>emerge --pretend mypkg</c> i
    sprawdzenie czy nie zawiera konfliktów.
  </li>
  <li>Zawsze należy uaktualnić plik <path>ChangeLog</path> przed wysłaniem</li>
  <li>
    Zawsze powinniśmy wysłać uaktualniony plik <path>package.mask</path> przed
    uaktualnionym pakietem, w razie gdyby wystąpiły konflikty podczas wysyłania
    pliku <path>package.mask</path>.
  </li>
  <li>
    Zawsze powinniśmy wysyłać wszystkie pliki danego pakietu za jednym razem,
    nie pojedynczo. Jeśli wysyłamy pakiet z nową licencją albo taki, który jest
    zamaskowana, najpierw należy wysłać uaktualniony plik
    <path>package.mask</path> i/lub licencję, następnie plik ebuild,
    <path>ChangeLog</path>, łatki i plik <uri
    link="?part=2&amp;chap=4">metadata.xml</uri> wszystkie za jednym razem, aby
    uniknąć uszkodzenia systemów użytkowników.
  </li>
</ul>

</body>
</subsection>
<subsection>
<title>Katalog files</title>
<body>

<p>
Jak wspominaliśmy wcześniej, w każdym katalogu pakietu znajduje się podkatalog
<path>files/</path>. W nim należy umieszczać wszelkie łatki, pliki
konfiguracyjne lub inne pliki pomocnicze. Pliki większe niż około 20KB powinny
być zamieszczane na serwerach lustrzanych, aby zmniejszyć ilość
(niepotrzebnych) plików, które nasi użytkownicy będą musieli ściągnąć. Warto
rozważyć taki schemat nazywania tworzonych poprawek, dzięki którym pakiet w
ogóle się zbuduje, aby uwzględniały wersję w nazwie, na przykład
<path>pakiet-1.0-gentoo.diff</path> lub prościej, <path>1.0-gentoo.diff</path>.
Przy okazji człon <path>gentoo</path> informuje, że poprawka ta została
stworzona przez nas, deweloperów Gentoo, a nie pobrana z listy dyskusyjnej albo
innego miejsca. Raz jeszcze: nie należy kompresować tych plików, ponieważ CVS
nie radzi sobie dobrze z plikami binarnymi.
</p>

<p>
Warto rozważyć dodawanie przedrostka lub przyrostka (na przykład
<path>mypkg-1.0</path>) do wszystkich plików, które umieszczamy w katalogu
<path>files/</path>, aby pliki wykorzystywane z konkretną wersją ebuilda można
było łatwo odróżnić od siebie. Ułatwia to porównywanie zmian pomiędzy
poprawkami. Ogólnie jest to dobry pomysł. :) Możemy użyć innego przyrostka,
jeśli chcemy, aby nazwa pliku łatki przekazywała więcej informacji.
</p>

<p>
Jeśli w katalogu <path>files/</path> chcemy umieścić więcej plików, warto
stworzyć podkatalogi, na przykład <path>files/1.0/</path> i umieszczać
odpowiednie pliki w ich własnych podkatalogach. Gdy używamy tej metody, nie
jest już konieczne dodawanie informacji o wersji do nazw plików. Często jest to
więc bardziej wygodne.
</p>

</body>
</subsection>
</section>
<section>
<title>Skrypty ebuild</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
Skrypty ebuild są podstawą całego systemu Portage. Zawierają wszelkie
informacje potrzebne do pobrania, rozpakowania, skompilowania i instalacji
zestawu źródeł, a także wykonania ewentualnych czynności poprzedzających i/lub
następujących po instalacji i/lub deinstalacji. Pomimo iż większość Portage
napisana jest w języku Python, same skrypty ebuild napisane są w bashu,
ponieważ wykorzystanie języka skryptowego powłoki pozwala nam na wykonywanie
komend tak samo jak z wiersza poleceń. Jednym z najważniejszych założeń
projektowych skryptów ebuild jest nazwanie zawartych w nim poleceń analogicznie
do tych, które wypisywalibyśmy, instalując pakiet ręcznie poprzez wiersz
poleceń. Również z tego względu użycie składni basha jest bardzo wskazane.
</p>

<p>
Skrypty ebuild są interpretowane przez komendy <c>ebuild</c> i <c>emerge</c>.
Wyobraźmy sobie polecenie <c>ebuild</c> jako niskopoziomowe narzędzie, służące
do budowania. Potrafi zbudować i zainstalować pojedynczy ebuild, ale nic poza
tym. Sprawdzi czy zależności są spełnione, ale nie będzie próbowało ich
automatycznie spełnić. Z drugiej strony polecenie <c>emerge</c> jest
wysokopoziomowym "silnikiem" dla polecenia <c>ebuild</c> i potrafi w razie
potrzeby automatycznie zainstalować zależności, wykonać instalacje symulowane
<e>pretend</e>, aby użytkownik mógł dowiedzieć się jakie pakiety zostaną
zainstalowane - i dużo więcej. Ogólnie polecenie <c>emerge</c> jest lepsze od
<c>ebuild</c> pod każdym względem, oprócz jednego. Za pomocą <c>ebuild</c>
możemy stopniowo i pojedynczo wykonywać poszczególne fazy instalacji pakietu
(pobieranie źródeł, rozpakowanie, kompilacja, instalacja i integracja pakietu z
systemem). Jest to nieocenione narzędzie do debugowania dla deweloperów,
ponieważ umożliwia zawężenie problemu z ebuildem do konkretnego fragmentu
skryptu ebuild.
</p>

</body>
</subsection>
<subsection>
<title>Nazewnictwo plików ebuild</title>
<body>

<p>
Nazwa pliku ebuild składa się z czterech logicznych podsekcji:
</p>

<p>
<c>pkg-ver{_suf{#}}{-r#}.ebuild</c>
</p>

<note>
Nawiasy klamrowe (<c>{}</c>) otaczają opcjonalne pola i same nie występują w
nazwie pakietu. Znak "<c>#</c>" oznacza dowolną dodatnią liczbę różną od zera.
</note>

<p>
Pierwsza podsekcja, <c>pkg</c>, to nazwa pakietu. Powinna ona zawierać
jedynie małe litery, cyfry od 0 do 9 oraz dowolną liczbę pojedynczych znaków
minus (<c>-</c>), podkreślenia (<c>_</c>) lub plus (<c>+</c>).
Przykłady: <c>util-linux</c>, <c>sysklogd</c> i <c>gtk+</c>. W Portage można
znaleźć kilka pakietów, które nie spełniają tych wymogów, ale <e>nasze</e>
pakiety muszą je spełniać.
</p>

<p>
Druga podsekcja, <c>ver</c> to wersja pakietu, która zwykle powinna odpowiadać
wersji głównego archiwum ze źródłami. Najczęściej wersja składa się z dwóch lub
trzech (czasem więcej) liczb oddzielonych kropkami, na przykład w ten sposób:
<c>1.2</c> lub <c>4.5.2</c>. Czasem bezpośrednio za ostatnią liczbą może
pojawić się pojedyncza litera, na przykład <c>1.4b</c> lub <c>2.6h</c>. Wersja
pakietu połączona jest myślnikiem z jego nazwą. Przykładowo: <c>coś-1.0</c>,
<c>bla-2.4.6</c>.
</p>

<impo>
Chcąc użyć litery poprzedzającej numer wersji należy mieć na uwadze, że <e>nie
powinna</e> ona oznaczać statusu alpha lub beta pakietu, ponieważ alpha i beta
to <e>wersje zapoznawcze</e> (ang. prerelease), natomiast wersje z literą na
początku to <e>nowsze wersje</e>. To istotne rozróżnienie, ponieważ Portage
używa numeru wersji ebuilda do określenia czy jest on nowszy czy starszy od
pozostałych pakietów o tej samej nazwie i w tej samej kategorii. Jest więc
bardzo ważne, aby numery wersji wiernie odzwierciedlały wersję pakietu i
Portage właściwie wykonywał sprawdzanie zależności.
</impo>

<p>
Trzecia podsekcja, <c>{_suf{#}}</c> jest opcjonalna i może zawierać jeden z
następujących przyrostków, wymienionych w kolejności od oznaczających najstarsze
wydanie po najnowsze:
</p>

<table>
<tr>
  <th>Przyrostek</th><th>Znaczenie</th>
</tr>
<tr>
  <ti><c>_alpha</c></ti><ti>Wydanie alpha</ti>
</tr>
<tr>
  <ti><c>_beta</c></ti><ti>Wydanie beta</ti>
</tr>
<tr>
  <ti><c>_pre</c></ti><ti>Wersja zapoznawcza (prerelease)</ti>
</tr>
<tr>
  <ti><c>_rc</c></ti><ti>Kadynat do wydania oficjalnego (Release candidate)</ti>
</tr>
<tr>
  <ti>(none)</ti><ti>Oficjalne wydanie</ti>
</tr>
<tr>
  <ti>
    <c>_p</c></ti><ti>Etap poprawek (patch level) (zwykle za przyrostkiem
    występuje liczba całkowita)</ti>
</tr>
</table>

<p>
Po każdym z tych przyrostków może zostać dodana dodatnia liczba całkowita różna
od zera, na przykład <c>linux-2.4.0_pre10</c>. Zakładając identyczne wersje,
przyrostki są ułożone następująco (mniejszy oznacza starszy): <c>_alpha</c> &lt;
<c>_beta</c> &lt; <c>_pre</c> &lt; <c>_rc</c> &lt; (brak przyrostka) &lt;
<c>_p</c>.
</p>

<p>
Podczas porównywania liczb poprzedzonych identycznymi przyrostkami za nowszą
zostanie uznana większa liczba całkowita. Przykład: <c>bla-1.0_alpha4</c>
jest nowsza niż <c>bla-1.0_alpha3</c>.
</p>

<p>
Czwarta podsekcja nazwy pakietu oznacza wewnętrzny numer rewizji
specyficznej dla systemu Gentoo Linux. Jest on opcjonalny, podobnie jak
przyrostek. Znak <c>#</c> jest dodatnią liczbą całkowitą różną od zera, na
przykład <c>pakiet-4.5.3-r3</c>.
</p>

<p>
Numer rewizji jest niezależny od wersji archiwum źródłowego i informuje, iż
dostępna jest nowa i poprawiona wersja danego pakietu, specyficzna dla systemu
Gentoo Linux. Pierwsze wydania pakietów nie mają numeru rewizji, co oznacza, że
pakiet <c>package-4.5.3</c> Portage potraktuje jak mającą zerowy numer rewizji.
Oznacza to, że pakiety zliczane będą w następującej kolejności: <c>1.0</c>
(wersja początkowa), <c>1.0-r1</c>, <c>1.0-r2</c>, itd.
</p>

<p>
Dokonując znacznych zmian w istniejącym pliku ebuild powinniśmy skopiować go
do nowego pliku z numerem rewizji zwiększonym o 1. Należy pamiętać, aby zawsze
odnotowywać zmiany <e>zarówno</e> w pliku <path>ChangeLog</path>, jak i w
komunikacie wysyłania. Pominięcie choć jednego jest wbrew regułom.
</p>

<p>
...w zasadzie to mamy też <e>piątą</e> sekcję nazwy pliku ebuild -- samo
rozszerzenie <c>.ebuild</c>.
</p>

</body>
</subsection>
<subsection>
<title>Zawartość pliku ebuild</title>
<body>

<p>
W tej części zajmiemy się wprowadzeniem do plików ebuild. Aby zobaczyć listę
wszystkiego, co można w nich zrobić, warto przeczytać stronę podręcznika
systemowego man, gdzie są informacje na temat formatu skryptów ebuild, ich
zmiennych i funkcji: <c>man 5 ebuild</c>.
</p>

<p>
<b>Nagłówki</b>
</p>

<p>
Nagłówek wysyłanego pliku ebuild powinien być <e>dokładnie</e> taki sam jak ten
w pliku <path>/usr/portage/header.txt</path>. Nie należy modyfikować go w żaden
sposób, a przede wszystkim należy upewnić się, że linia zawierająca napis
<c>&#36;Header: &#36;</c> jest nienaruszona.
</p>

<p>
Pierwsze trzy linie powinny wyglądać mniej-więcej tak:
</p>

<pre caption="Poprawny nagłówek">
# Copyright 1999-2005 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# &#36;Header: &#36;
</pre>

<p>
<b>Zmienne</b>
</p>

<p>
Pierwsza część każdego pliku ebuild składa się z kilku zmiennych. Dzielą się one
na trzy kategorie wymienione poniżej:
</p>

<ul>
  <li>READ: zmiennych tych możemy użyć, ale <e>nie wolno</e> ich ustawiać</li>
  <li>MUST: zmienne, które <e>koniecznie należy ustawić</e></li>
  <li>OPT: zmienne, które powinniśmy ustawić</li>
</ul>

<table>
<tr>
  <th>Zmienna</th>
  <th>Kategoria</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><c>P</c></ti>
  <ti>READ</ti>
  <ti>Nazwa i wersja pakietu.</ti>
</tr>
<tr>
  <ti><c>PN</c></ti>
  <ti>READ</ti>
  <ti>Nazwa pakietu.</ti>
</tr>
<tr>
  <ti><c>PV</c></ti>
  <ti>READ</ti>
  <ti>Wersja pakietu.</ti>
</tr>
<tr>
  <ti><c>PR</c></ti>
  <ti>READ</ti>
  <ti>
    Zawiera numer rewizji lub <c>r0</c>, jeśli pakiet nie posiada tego numeru.
  </ti>
</tr>
<tr>
  <ti><c>PVR</c></ti>
  <ti>READ</ti>
  <ti>Zawiera numer wersji razem z numerem rewizji.</ti>
</tr>
<tr>
  <ti><c>PF</c></ti>
  <ti>READ</ti>
  <ti>Zawiera pełną nazwę pakietu <c>${PN}-${PVR}</c>.</ti>
</tr>
<tr>
  <ti><c>A</c></ti>
  <ti>READ</ti>
  <ti>
    Rozdzielona spacjami lista nazw plików z <c>SRC_URI</c>. Nie uwzględnia
    ścieżek URL, tylko same nazwy plików.
  </ti>
</tr>
<tr>
  <ti><c>DISTDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Zawiera ścieżkę do katalogu <path>distfiles</path>, w którym zwykle są
    przechowywane wszystkie pobrane pliki ze źródłami programów. Zwykle jest to
    katalog <path>/usr/portage/distfiles</path>.
  </ti>
</tr>
<tr>
  <ti><c>FILESDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Zawiera ścieżkę do podkatalogu <path>files</path> z katalogu danego pakietu
    w drzewie Portage. Nie wolno modyfikować tej zmiennej.
  </ti>
</tr>
<tr>
  <ti><c>WORKDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Katalog główny katalogu roboczego danego ebuilda. Nic nie powinno być
    budowane na zewnątrz tego katalogu.
  </ti>
</tr>
<tr>
  <ti><c>S</c></ti>
  <ti>OPT</ti>
  <ti>
    Katalog źródłowy naszego pakietu. Zwykle jest to <c>${WORKDIR}/${P}</c>.
    Portage przyjmie tę wartość jako domyślną, nie trzeba jej więc ustawiać
    samemu.
  </ti>
</tr>
<tr>
  <ti><c>T</c></ti>
  <ti>READ</ti>
  <ti>
    Katalog tymczasowy naszego pakietu. Jest on używany jako wirtualny katalog
    <path>/tmp</path> podczas przetwarzania skryptu ebuild.
  </ti>
</tr>
<tr>
  <ti><c>D</c></ti>
  <ti>READ</ti>
  <ti>
    Katalog główny, do którego pakiet zostanie zainstalowany. Należy traktować
    go jako wirtualny katalog <path>/</path>.
  </ti>
</tr>
<tr>
  <ti><c>SLOT</c></ti>
  <ti>MUST</ti>
  <ti>
    Portage obsługuje instalowanie jednocześnie różnych wersji tego samego
    programu. Na przykład jeśli chcielibyśmy zainstalować jednocześnie GCC 2.95
    i GCC 3.2, należałoby ustawić zmienną <c>SLOT</c> w każdym pliku ebuild. W
    tym przypadku dla GCC 2.95 ustawilibyśmy zmienną <c>SLOT</c> na <c>2</c>, a
    dla GCC 3.2 na <c>3</c>.
    <br/>
    <b>Uwaga</b>: Podanie <c>0</c> jako wartości zmiennej <c>SLOT</c> oznacza,
    że dany pakiet ma tylko jedno możliwe ustawienie <c>SLOT</c> (innymi słowy,
    nie da się jej "SLOT-ować").
  </ti>
</tr>
<tr>
  <ti><c>LICENSE</c></ti>
  <ti>MUST</ti>
  <ti>
    Zmienna ta określa jaką licencją objęty jest program, na przykład GPL-2,
    BSD, itp... Zawartością tej zmiennej musi być poprawna licencja (jest nią
    dowolna licencja z pliku <path>/usr/portage/license/</path>). Jesli danej
    licencji nie ma w tym pliku, musi zostać tam dodana zanim plik ebuild
    znajdzie się w drzewie Portage. Jeśli licencja nie zezwala na redystrybucję
    programu, należy dodać <c>RESTRICT</c>="nomirror" do pliku ebuild.
  </ti>
</tr>
<tr>
  <ti><c>KEYWORDS</c></ti>
  <ti>MUST</ti>
  <ti>
    Zmienna ta pełni teraz kilka funkcji. Przede wszystkim określa na jakie
    architektury sprzętowe przeznaczony jest dany ebuild. Przykładowe wartości
    to: <e>x86, ppc, sparc, mips, alpha, arm, hppa, amd64 i ia64</e>. Więcej
    szczegółów można znaleźć w pliku profiles/arch.list. Jak nietrudno się
    domyślić, zmienną tę ustawiamy zgodnie z architekturą docelowej maszyny.
    Portage nie zezwoli maszynie x86 budować pakietów innych niż x86, zgodnie z
    tym, co jest podane w zmiennej <c>KEYWORDS</c>. Pakiety, które nie wspierają
    architektury danego komputera są automatycznie maskowane przez Portage.
    Jeśli flaga <c>KEYWORDS</c> posiada przedrostek <e>~</e>, oznacza to, że
    dany ebuild działa, ale powinien zostać przetestowany w kilku środowiskach,
    zanim może zostać uznany za stabilny. Jeśli zaś przed flagą <c>KEYWORDS</c>
    występuje znak <e>-</e>, dany pakiet nie będzie działać na danej
    architekturze. Pakiety jest uznawany za stabilny, jeśli nic nie poprzedza
    zmiennych zawartych w <c>KEYWORDS</c>. Ustawiając odpowiednio zmienną
    <c>ACCEPT_KEYWORDS</c> w pliku <path>make.conf</path> definiujemy którym z
    powyższych typów pakietów zezwalamy na instalację.
  </ti>
</tr>
<tr>
  <ti><c>DESCRIPTION</c></ti>
  <ti>MUST</ti>
  <ti><e>Krótki</e>, mieszczący się w jednej linii opis pakietu.</ti>
</tr>
<tr>
  <ti><c>SRC_URI</c></ti>
  <ti>MUST</ti>
  <ti>
    URL-e każdego pliku ze źródłami pakietu, rozdzielone białym znakiem (np.
    spacją lub znakiem końca linii). W zmiennych SRC_URI i S nie powinno się
    umieszczać numerów wersji. Powinniśmy zawsze stosować zmienne ${PV} lub
    ${P}, a jeśli numer wersji nie pokrywa się z nazwą pliku zawierającego
    źródła, należy stworzyć zmienną ${MY_P} i użyć jej zamiast dwóch
    poprzednich.
  </ti>
</tr>
<tr>
  <ti><c>HOMEPAGE</c></ti>
  <ti>MUST</ti>
  <ti>
    Strona domowa pakietu. Jeśli nie możemy znaleźć oficjalnej strony, można
    podać odnośnik z <uri link="http://freshmeat.net/">freshmeat.net</uri> lub
    podobnej strony z bazą danych programów. Nigdy nie należy odnosić się do
    innej zmiennej wewnątrz tej. Musi ona zawierać tylko czysty tekst.
  </ti>
</tr>
<tr>
  <ti><c>IUSE</c></ti>
  <ti>MUST</ti>
  <ti>
    W zmiennej tej zamieszczamy flagi <c>USE</c> z jakich korzysta nasz pakiet.
    Należy pamiętać, że nie wolno tutaj umieścić <c>KEYWORDS</c>!
  </ti>
</tr>
<tr>
  <ti><c>DEPEND</c></ti>
  <ti>OPT</ti>
  <ti>
    Tutaj wymieniamy zależności potrzebne do zbudowania pakietu. Więcej
    informacji na temat składni znajdziemy w sekcji <uri
    link="#doc_chap5">Zależności pakietu</uri>.
  </ti>
</tr>
<tr>
  <ti><c>RDEPEND</c></ti>
  <ti>OPT</ti>
  <ti>
    Tutaj wymieniamy zależności potrzebne do uruchomienia programu z pakietu.
    Jak wspomniano wyżej, więcej szczegółów można znaleźć w sekcji <uri
    link="#doc_chap5">Zależności pakietu</uri>.
  </ti>
</tr>
</table>

<p>
<b>Funkcje</b>
</p>

<p>
W plikach ebuild można zdefiniować wiele różnych funkcji, które kontrolują
proces budowania i instalacji pakietu.
</p>

<table>
<tr>
  <th>Funkcja</th>
  <th>Zastosowanie</th>
</tr>
<tr>
  <ti><c>pkg_setup</c></ti>
  <ti>
    Funkcja ta służy do wykonywania wszelkich wstępnych czynności. Może to
    obejmować sprawdzenie czy istnieje już plik konfiguracyjny. Jeśli w tym
    miejscu konieczne jest dodanie użytkowników, należy również sprawdzić to
    w funkcji <c>pkg_preinst()</c> zanim pakiet zostanie zainstalowany.
  </ti>
</tr>
<tr>
  <ti><c>pkg_nofetch</c></ti>
  <ti>
    W tym miejscu informujemy użytkownika o tym, co musi zrobić, jeśli z
    jakiegoś powodu (na przykład licencji) źródła nie mogą zostać automatycznie
    pobrane przez Portage. Jednocześnie należy ustawić zmienną
    <c>RESTRICT="fetch"</c>. W niniejszej funkcji wolno nam jedynie
    wyświetlać komunikaty, nie należy wywoływać polecenia <c>die</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_unpack</c></ti>
  <ti>
    Tej funkcji należy użyć, aby rozpakować źródła pakietu, nałożyć poprawki i
    uruchomić zewnętrzne programy, na przykład autotools. Domyślnie funkcja ta
    rozpakuje pliki wymienione w zmiennej <c>A</c>. Początkowy katalog roboczy
    definiuje zmienna <c>WORKDIR</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_compile</c></ti>
  <ti>
    Za pomocą tej funkcji konfigurujemy i budujemy pakiet. Początkowy katalog
    roboczy definiuje zmienna <c>S</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_install</c></ti>
  <ti>
    Tej funkcji użyjemy, aby zainstalować pakiet w katalogu określonym przez
    zmienną <c>D</c>. Jesli pakiet korzysta z automake, możemy tego łatwo
    dokonać poprzez <c>make DESTDIR=${D} install</c>. <e>Należy upewnić się, że
    pakiet wszystkie swoje pliki zainstaluje używając <c>D</c> jako katalogu
    głównego!</e> Początkowy katalog roboczy definiuje zmienna <c>S</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_test</c></ti>
  <ti>
    Funkcja ta jest wykonywana tylko wtedy, gdy zmienna
    <c>FEATURES="test"</c> jest ustawiona, a zmienna
    <c>RESTRICT="test"</c> nie jest ustawiona. Domyślnie wywołuje dostępną
    funkcję testującą z plików Makefile, znajdujących się w katalogu
    zdefiniowanym przez zmienną <c>${S}</c>, uruchamiając albo "make test" albo
    "make check", w zależności od tego, co jest dostępne. Funkcję tę można
    nadpisać i zaimplementować własną metodę testowania pakietu.
  </ti>
</tr>
<tr>
  <ti><c>pkg_preinst</c></ti>
  <ti>
    Polecenia zawarte w tej funkcji zostaną wykonane tuż <e>przed
    zintegrowaniem</e> obrazu pakietu z systemem plików.
  </ti>
</tr>
<tr>
  <ti><c>pkg_postinst</c></ti>
  <ti>
    Polecenia zawarte w tej funkcji zostaną wykonane tuż <e>po
    zintegrowaniu</e> obrazu pakietu z systemem plików.
  </ti>
</tr>
<tr>
  <ti><c>pkg_prerm</c></ti>
  <ti>
    Polecenia zawarte w tej funkcji zostaną wykonane tuż <e>przed
    odinstalowaniem</e> obrazu pakietu z systemu plików.
  </ti>
</tr>
<tr>
  <ti><c>pkg_postrm</c></ti>
  <ti>
    Polecenia zawarte w tej funkcji zostaną wykonane tuż <e>po
    odinstalowaniu</e> obrazu pakietu z systemu plików.
  </ti>
</tr>
<tr>
  <ti><c>pkg_config</c></ti>
  <ti>
    Za pomocą tej funkcji możemy przygotować początkową konfigurację pakietu
    tuż po jego instalacji. Wszystkie ścieżki w obrębie tej funkcji powinny być
    poprzedzone zmienną <c>ROOT</c>, wskazującą podany przez użytkownika
    katalog instalacji, który niekoniecznie musi być katalogiem <path>/</path>.
    Funkcja ta wykonywana jest <e>tylko i wyłącznie</e> wtedy, gdy użytkownik
    wyda polecenie: <c>emerge --config =${PF}</c>.
  </ti>
</tr>
</table>

<p><b>Funkcje pomocnicze</b></p>

<p>
W naszych skryptach ebuild możemy użyć także następujących funkcji pomocniczych.
</p>

<table>
<tr>
  <th>Funkcja</th>
  <th>Zastosowanie</th>
</tr>
<tr>
  <ti><c>use</c></ti>
  <ti>
    Sprawdza czy zdefiniowane zostały podane flagi USE. Jeśli tak, funkcja
    zwróci wartość odpowiadającą logicznej prawdzie. Niezależnie od wyniku
    działania, funkcja nie wypisuje żadnych komunikatów na standardowe
    wyjście. Aby uzyskać informacje na standardowym wyjściu należy skorzystać z
    funkcji <c>usev</c>, które wypisze flagę USE, jeśli została ona
    zdefiniowana.
  </ti>
</tr>
<tr>
  <ti><c>has_version</c></ti>
  <ti>
    Zwraca 1 jeśli w systemie jest żądana wersja danego pakietu. Na przykład
    <c>has_version >=sys-libs/glibc-2.3.0</c>.
  </ti>
</tr>
<tr>
  <ti><c>best_version</c></ti>
  <ti>
    Zwraca informację <path>kategoria/pakiet-wersja</path> danego pakietu,
    podaną w formacie <path>kategoria/pakiet</path>. Na przykład
    <c>best_version x11-libs/gtk+extra</c>.
  </ti>
</tr>
<tr>
  <ti><c>use_with</c></ti>
  <ti>
    Funkcja ta sprawdza czy flaga USE została zdefiniowana i zwraca odpowiednio
    "--with-foobar" lub "--without-foobar". Jeśli podamy
    funkcji tylko jeden argument, oznacza to, że jest on zarówno flagą USE, jak
    i tekstem with/without. Podając zaś dwa, pierwszy z nich jest flagą USE, a
    drugi tekstem with/without. Na przykład <c>use_with truetype freetype</c>
    wypisze "--with-freetype", jeśli zmienna <c>USE</c> zawiera truetype.
  </ti>
</tr>
<tr>
  <ti><c>use_enable</c></ti>
  <ti>
    Tak samo jak w przypadku <c>use_with</c>, ale zwraca odpowiednio
    "--enable-blabla" lub "--disable-blabla".
  </ti>
</tr>
<tr>
  <ti><c>check_KV</c></ti>
  <ti>
    Sprawdza czy Portage zna wersję jądra. Jeśli nie, wypisze komunikat błędu i
    zakończy działanie niepowodzeniem. Jeśli w naszym skrypcie potrzebujemy
    wersji jądra, należy użyć zmiennej <c>KV</c>, która jest automatycznie
    definiowana przez Portage. W systemie działającym na jądrze
    gentoo-sources-2.4.20-r6, zmienna <c>KV</c> będzie miała wartość "2.4.20".
  </ti>
</tr>
<tr>
  <ti><c>keepdir</c></ti>
  <ti>
    Tworzy (jeśli jest to konieczne) plik <path>.keep</path> w danym katalogu,
    aby katalog ten nie został automatycznie usunięty. <e>Nigdy</e> nie należy
    tworzyć pliku <path>.keep</path> ręcznie. Jeśli zasada działania funkcji
    <c>keepdir</c> zmieni się w Portage, samodzielne tworzenie tego pliku
    popsuje pakiet.
  </ti>
</tr>
<tr>
  <ti><c>econf</c></ti>
  <ti>
    Wykonuje polecenie <c>./configure</c> z wszelkimi niezbędnymi zmianami
    w ścieżkach (prefix, host, mandir, infodir, datadir, sysconfdir,
    localstatedir). Możemy opcjonalnie przekazać dodatkowe argumenty do
    <c>./configure</c>, przekazując je funkcji <c>econf</c> przy wywołaniu, zaś
    użytkownicy w razie potrzeby mogą ustawić zmienną środowiskową
    <c>EXTRA_ECONF</c>. Opcje przekazane skryptowi configure przejmują
    pierwszeństwo w odwrotnej kolejności niż zostały podane. Innymi słowy,
    pierwszy przekazany argument zostanie zawsze zastąpiony ostatnim.
  </ti>
</tr>
<tr>
  <ti><c>einstall</c></ti>
  <ti>
    Wykonuje polecenie <c>make install</c> z wszystkimi niezbędnymi zmianami w
    ścieżkach (prefix, datadir, mandir, infodir, datadir, sysconfdir,
    localstatedir). Jak wyżej, można przekazać dodatkowe argumenty do komendy
    make, przekazując je funkcji <c>einstall</c> przy jej wywołaniu. Zauważmy
    jednak, że preferowanym sposobem zainstalowania pakietu jest wywołanie
    komendy <c>make install DESTDIR=${D}</c>, a nie za pomocą <c>einstall</c>.
    Komenda ta używana jest tylko zastępczo w przypadku popsutych plików make.
  </ti>
</tr>
<tr>
  <ti><c>die</c></ti>
  <ti>
    Powoduje przerwanie aktualnego procesu. Poinformuje użytkownika o przyczynie
    problemu, wypisując podane argumenty. Przekazanie argumentów funkcji
    <c>die</c> jest wysoce wskazane, jeśli mamy więcej niż jedno jej wywołanie w
    danej funkcji. O wiele trudniej jest wyśledzić problemy, jeśli nie wiemy
    <e>gdzie</e> problem wystąpił.
  </ti>
</tr>
<tr>
  <ti><c>elog</c></ti>
  <ti>
    Przekazuje użytkownikowi istotne informacje. Argument przekazany funkcji
    <c>elog</c> będzie komunikatem, który zobaczy użytkownik. Nie należy używać
    tej funkcji do wypisywania nagłówków w rodzaju
    "*************************************". Sam fakt, że została użyta funkcja
    <c>einfo</c> wystarczy, aby przyciągnąć uwagę użytkownika. Dodatkowo
    komunikat jest zapisywany przy użyciu systemu ELOG maszyny Portage.
  </ti>
</tr>
<tr>
  <ti><c>einfo</c></ti>
  <ti>
    Wyświetla mało istotne komunikaty informacyjne, które nie muszą być
    rejestrowane.
  </ti>
</tr>
</table>

<p>
<b>Funkcje pomocnicze dostarczone przez eutils.eclass</b>
</p>

<p>
Możemy użyć następujących funkcji pomocniczych, które są dostępne w naszych
ebuildach poprzez eclass "eutils". Należy upewnić się, że użyliśmy instrukcji
<c>inherit eutils</c>, inaczej funkcje te nie będą działać.
</p>

<table>
<tr>
  <th>Funkcja</th>
  <th>Zastosowanie</th>
</tr>
<tr>
  <ti><c>epatch</c></ti>
  <ti>
    Funkcja ta jest bardziej przyjazną wersją polecenia <c>patch</c>. Działa ona
    nie tylko z łatkami w plikach tekstowych, ale też w plikach typu .bz2, .gz
    i .zip. Nie trzeba podawać opcji "-p", zaś opcje, które należy podać powinny
    być ustawione w zmiennej <c>EPATCH_OPTS</c>. Funkcja oczekuje pliku lub
    katalogu jako argumentu. Jeśli podamy katalog, wszystkie łatki w postaci
    "??${ARCH}_..." zostaną nałożone. Aby poprawka mogła być nałożona, musi
    pasować do naszej architektury, mieć napis "_all_" w nazwie pliku, lub
    zmienna <c>EPATCH_FORCE</c> musi być ustawiona na "yes".
  </ti>
</tr>
<tr>
  <ti><c>gen_usr_ldscript</c></ti>
  <ti>
    Funkcja ta tworzy w katalogu /usr/lib skrypty linkera dla dynamicznych
    bibliotek z katalogu /lib. Naprawia to problemy z linkowaniem gdy plik .so
    znajduje się w katalogu /lib, podczas gdy plik .a znajduje się w katalogu
    /usr/lib.
  </ti>
</tr>
<tr>
  <ti><c>edos2unix</c></ti>
  <ti>
    Funkcja ta robi dokładnie to samo co program <c>dos2unix</c>.
  </ti>
</tr>
<tr>
  <ti><c>egetent</c></ti>
  <ti>
    Funkcja egetent pełni rolę interfejsu dla <c>getnet</c> pod Linuksem lub
    dla <c>nidump</c> pod Mac OS X (R).
  </ti>
</tr>
<tr>
  <ti><c>enewuser</c></ti>
  <ti>
    Tworzy nowego użytkownika. Funkcja oczekuje wymaganego parametru z nazwą
    użytkownika i szeregu opcjonalnych argumentów: <c>$2</c> zawiera UID, zaś
    gdy przekażemy -1 użyty zostanie następny dostępny; <c>$3</c> zawiera
    powłokę systemową (-1 to wartość domyślna), domyślnie będzie to
    <path>/bin/false</path>; <c>$4</c> to katalog domowy, domyślnie
    <path>/dev/null</path>, <c>$5</c> zawiera grupy, do których użytkownik
    powinien zostać dodany (domyślnie żadne), zaś <c>$6</c> może zawierać różne
    dodatkowe opcje jakie chce się przekazać do <c>useradd</c>.
  </ti>
</tr>
<tr>
  <ti><c>enewgroup</c></ti>
  <ti>
    Dodaje nową grupę. Funkcja oczekuje wymaganego parametru z nazwą grupy -
    opcjonalny drugi argument to konkretny GID.
  </ti>
</tr>
<tr>
  <ti><c>make_desktop_entry</c></ti>
  <ti>
    Tworzy wpis desktop wg standardu freedesktop.org. Pierwszy argument zawiera
    ścieżkę do pliku binarnego z programem. Dodatkowo drugi zawiera nazwę pliku
    ikony - domyślna wartość to <c>${PN}</c>. Trzeci może zawierać ścieżkę do
    pliku ikony - względną do ścieżki <path>/usr/share/pixmaps</path> lub pełną
    ścieżkę. Wartość domyślna to <c>${PN}</c>.png; czwarty może zawierać <uri
    link="http://standards.freedesktop.org/menu-spec/latest/apa.html">kategorię
    aplikacji</uri>, zaś piąty argument zawiera opcjonalną ścieżkę początkową
    dla aplikacji.
  </ti>
</tr>
<tr>
  <ti><c>check_license</c></ti>
  <ti>
    Wyświetla licencję aby użytkownik mógł ją przeczytać i zaakceptować. Jeśli
    nie podano argumentów, użyta zostanie licencja określona przez zmienną
    <c>${LICENSE}</c>.
  </ti>
</tr>
<tr>
  <ti><c>unpack_pdv</c></ti>
  <ti>
    Rozpakowuje archiwum wygenerowane przez pdv, przy czym pierwszy argument
    musi zawierać nazwę pliku archiwum, drugi zaś wartość "off_t", którą należy
    wygenerować ręcznie: <c>strace -elseek ${plik}</c>, zaś dla przykładowego
    wywołania takiego jak to: "lseek(3, -4, SEEK_END)"  przekazalibyśmy wartość
    "4".
  </ti>
</tr>
<tr>
  <ti><c>unpack_makeself</c></ti>
  <ti>
    Rozpakowuje archiwum wygenerowane przez makeself, wymaga nazwy pliku do
    rozpakowania jako argumentu.
  </ti>
</tr>
<tr>
  <ti><c>cdrom_get_cds</c></ti>
  <ti>
    Prosi użytkownika o włożenie płyty CD do czytnika. Rozpoznaje czy płyta jest
    właściwa sprawdzając, czy znajduje się na niej plik o nazwie podanej jako
    argument funkcji. Użytkownik będzie kolejno proszony o włożenie tylu płyt,
    ile podamy argumentów. Miejsce zamontowania płyty zostanie ustawione w
    zmiennej <c>${CDROM_ROOT}</c>.
  </ti>
</tr>
<tr>
  <ti><c>cdrom_load_next_cd</c></ti>
  <ti>
    Ładuje następną płytę CD gdy już skończyliśmy z poprzednią. Jeśli funkcja
    zwróci wartość, zmienna <c>${CDROM_ROOT}</c> wskaże następną płytę CD.
  </ti>
</tr>
<tr>
  <ti><c>strip-linguas</c></ti>
  <ti>
    Zadaniem tej funkcji jest upewnienie się, że zmienna LINGUAS zawiera tylko
    obsługiwane przez pakiet języki, podawane jako argumenty dla funkcji. Jeśli
    pierwszym argumentem jest -i, tworzona jest lista plików .po w określonych
    katalogach i użyta jest część wspólna list. Jeśli zaś pierwszym
    argumentem jest -u, tworzona jest lista plików .po w określonych katalogach
    i użyta jest suma list.
  </ti>
</tr>
</table>

<p>
<b>Funkcje pomocnicze dostarczone przez flag-o-matic.eclass</b>
</p>

<p>
Możemy użyć następujących funkcji pomocniczych, które są dostępne w naszych
ebuildach poprzez eclass "flag-o-matic". Należy upewnić się, że użyliśmy
instrukcji <c>inherit flag-o-matic</c>, inaczej funkcje te nie będą działać.
Nigdy nie należy ręcznie modyfikować ustawień kompilatora, zamiast tego
powinniśmy użyć funkcji z eclass flag-o-matic do czynności typu odfiltrowanie
sprawiających kłopoty flag.
</p>

<table>
<tr>
  <th>Funkcja</th>
  <th>Zastosowanie</th>
</tr>
<tr>
  <ti><c>filter-flags</c></ti>
  <ti>
    Funkcja ta usuwa konkretne flagi ze zmiennych <c>C[XX]FLAGS</c> - usuwane
    są tylko flagi, których nazwy w całości pasują do nazw tych, które chcemy
    usunąć.
  </ti>
</tr>
<tr>
  <ti><c>append-flags</c></ti>
  <ti>
    Funkcja ta dodaje dodatkowe flagi do istniejących zmiennych
    <c>C[XX]FLAGS</c>.
  </ti>
</tr>
<tr>
  <ti><c>replace-flags</c></ti>
  <ti>
    Zamienia w zmiennych <c>C[XX]FLAGS</c> flagę podaną jako pierwszy argument
    na flagę podaną jako drugi.
  </ti>
</tr>
<tr>
  <ti><c>replace-cpu-flags</c></ti>
  <ti>
    Zamienia flagi -march=... lub -mcpu=... zawierające drugi argument
    funkcji flagami z pierwszego argumentu.
  </ti>
</tr>
<tr>
  <ti><c>strip-flags</c></ti>
  <ti>
    Usuwa wszystkie flagi z wyjątkiem tych podanych w zmiennej
    <c>ALLOWED_FLAGS</c>.
  </ti>
</tr>
<tr>
  <ti><c>strip-unsupported-flags</c></ti>
  <ti>
    Usuwa ze zmiennych <c>C[XX]FLAGS</c> wszystkie flagi, których nie obsługuje
    aktualnie działająca wersja kompilatora GCC.
  </ti>
</tr>
<tr>
  <ti><c>get-flag</c></ti>
  <ti>
    Znajduje flagę i wypisuje jej wartość.
  </ti>
</tr>
<tr>
  <ti><c>is-flag</c></ti>
  <ti>
    Funkcja ta zwraca wartość true jeśli dana flaga jest aktualnie ustawiona w
    zmiennych <c>C[XX]FLAGS</c>; nazwy flag muszą się zgadzać w całości, aby
    zostały dopasowane.
  </ti>
</tr>
<tr>
  <ti><c>append-ldflags</c></ti>
  <ti>
    Funkcja ta dodaje dodatkowe flagi do istniejącej zmiennej <c>LDFLAGS</c>.
  </ti>
</tr>
<tr>
  <ti><c>filter-ldflags</c></ti>
  <ti>
    Usuwa podane flagi ze zmiennej <c>LDFLAGS</c>, przy czym nazwy flag muszą
    się zgadzać w całości, aby zostały dopasowane.
  </ti>
</tr>
<tr>
  <ti><c>fstack-flags</c></ti>
  <ti>
    Dodaje flagę -fno-stack-protector, która znosi flagi -fstack-protector i
    -fstack-protector-all.
  </ti>
</tr>
</table>

<p><b>Funkcje pomocnicze dostępne w toolchain-funcs.eclass</b></p>

<p>
Możemy użyć następujących funkcji pomocniczych, które są dostępne w naszych
ebuildach poprzez eclass "toolchain-funcs". Należy upewnić się, że użyliśmy
instrukcji <c>inherit toolchain-funcs</c>, inaczej funkcje te nie będą działać.
Nigdy nie należy ręcznie modyfikować ustawień kompilatora lub binutils, zamiast
tego powinniśmy użyć funkcji z eclass flag-o-matic do określenia kompilatorów i
binutils.
</p>

<p>
Poniższe funkcje stosuje się, aby wspierać kompilację skrośną i kompilator icc.
Powinny być one używane gdy pakiet wprost używa gcc, g++, ld, ranlib lub
jakichkolwiek poniższych narzędzi. Na ogół pakiety, które używają narzędzi do
autokonfiguracji wykrywają kompilację skrośną automatycznie i nie potrzebują
poniższych funkcji.
</p>

<table>
<tr>
  <th>Funkcja</th>
  <th>Zastosowanie</th>
</tr>
<tr>
  <ti><c>tc-getAR</c></ti>
  <ti>Zwraca nazwę archiwizatora.</ti>
</tr>
<tr>
  <ti><c>tc-getAS</c></ti>
  <ti>Zwraca nazwę asemblera.</ti>
</tr>
<tr>
  <ti><c>tc-getCC</c></ti>
  <ti>Zwraca nazwę kompilatora C.</ti>
</tr>
<tr>
  <ti><c>tc-getCXX</c></ti>
  <ti>Zwraca nazwę kompilatora C++.</ti>
</tr>
<tr>
  <ti><c>tc-getLD</c></ti>
  <ti>Zwraca nazwę linkera.</ti>
</tr>
<tr>
  <ti><c>tc-getNM</c></ti>
  <ti>Zwraca nazwę narzędzia do inspekcji symboli/obiektów.</ti>
</tr>
<tr>
  <ti><c>tc-getRANLIB</c></ti>
  <ti>Zwraca nazwę programu indeksującego archiwa</ti>
</tr>
<tr>
  <ti><c>tc-getF77</c></ti>
  <ti>Zwraca nazwę kompilatora fortrana.</ti>
</tr>
<tr>
  <ti><c>tc-getLD</c></ti>
  <ti>Zwraca nazwę linkera</ti>
</tr>
<tr>
  <ti><c>tc-getLD</c></ti>
  <ti>Zwraca nazwę linkera.</ti>
</tr>
<tr>
  <ti><c>tc-getGCJ</c></ti>
  <ti>Zwraca nazwę kompilatora javy.</ti>
</tr>
<tr>
  <ti><c>tc-getBUILD_CC</c></ti>
  <ti>Zwraca nazwę kompilatora C do budowania.</ti>
</tr>
<tr>
  <ti><c>tc-is-cross-compiler</c></ti>
  <ti>Prosty sposób na sprawdzenie czy używamy kompilatora skrośnego.</ti>
</tr>
<tr>
  <ti><c>gcc-fullversion</c></ti>
  <ti>Zwraca wersję tak samo jak polecenie $($CC -dumpversion)</ti>
</tr>
<tr>
  <ti><c>gcc-version</c></ti>
  <ti>Zwraca tylko postać &lt;major>.&lt;minor> wersji.</ti>
</tr>
<tr>
  <ti><c>gcc-major-version</c></ti>
  <ti>Zwraca część Major wersji.</ti>
</tr>
<tr>
  <ti><c>gcc-minor-version</c></ti>
  <ti>Zwraca część Minor wersji.</ti>
</tr>
<tr>
  <ti><c>gcc-micro-version</c></ti>
  <ti>Zwraca część Micro wersji.</ti>
</tr>
</table>

</body>
</subsection>
<subsection>
<title>Zasady pisania plików ebuild</title>
<body>

<p>
Pliki ebuild są tak naprawdę skryptami powłoki, powinniśmy więc przy ich edycji
używać trybu edycji skryptów powłoki naszego edytora. Należy stosować
odpowiednie wcięcia, wyłącznie przy pomocy znaków tabulacji -- <e>żadnych
spacji</e>. Należy się upewnić, że rozmiar tabulacji w naszym edytorze wynosi 4
spacje. Zawsze powinniśmy stosować nawiasy klamrowe wokół zmiennych
środowiskowych, czyli <c>${P}</c> zamiast <c>$P</c>.
</p>

<p>
Długie linie zawijamy za pomocą znaku ' \':
</p>

<pre caption="Zawijanie wierszy w plikach ebuild">
./configure \
--prefix=/usr || die "configure failed"
</pre>

<p>
Więcej szczegółów znajdziemy w pliku <path>skel.ebuild</path> (zwykle znajduje
się on w katalogu <path>/usr/portage</path>).
</p>

<p>
Warto zwrócić uwagę na domyślny plik vimrc w Gentoo jeśli używamy programu Vim
do edycji plików ebuild/eclass. Znajduje się on w katalogu
<path>/etc/vim/vimrc</path> i zawiera poprawne ustawienia wcięć i typów plików
dla plików ebuild i eclass. Jeszcze więcej możliwości, w tym specjalne
podświetlanie składni w plikach ebuild uzyskamy instalując
app-vim/gentoo-syntax.
</p>

<p>
Na systemach innych niż Gentoo podobne ustawienia zyskamy, dopisując poniższe
linijki do naszego pliku vimrc, albo jeszcze lepiej, instalując skrypty
gentoo-syntax, które są dostępne na serwerach lustrzanych Gentoo..
</p>

<pre caption="Konfiguracja vimrc do edycji plików ebuild">
au BufRead,BufNewFile *.e{build,class} let is_bash=1|setfiletype sh
au BufRead,BufNewFile *.e{build,class} set ts=4 sw=4 noexpandtab
</pre>

<p>
Jeśli używamy edytora Emacs możemy zainstalować app-emacs/gentoo-syntax 
(w GNU Emacs) lub app-xemacs/gentoo-syntax (w XEmacs). Pakiety te dostarczają
główne formy nagłówków oraz kolorowanie skłani ebuildów oraz innych
specyficznych dla Gentoo plików.
</p>

<p>
Jeśli zaś używamy edytora nano, szczęśliwie oszczędzono nam pracy. Wystarczy
tylko odkomentować sekcję dotyczącą ebuildów w pliku <path>/etc/nanorc</path>.
</p>

</body>
</subsection>
<subsection>
<title>Zmienne USE</title>
<body>

<p>
Dzięki zmiennym USE możliwe jest skonfigurowanie Portage, aby globalnie i
automatycznie włączało lub wyłączało pewne <e>opcjonalne, ustawiane przy
budowaniu</e> funkcje programów. Oto przykład. Załóżmy, że jesteśmy fanami
środowiska GNOME i chcielibyśmy, aby każdy ebuild, który daje możliwość
wkompilowania opcjonalnej obsługi tego środowiska zrobił to. W tym przypadku
należy dodać <c>gnome</c> do zmiennej <c>USE</c> w pliku
<path>/etc/make.conf</path>, a Portage automatycznie będzie dodawał opcjonalną
funkcjonalność GNOME do pakietów, jeśli jest ona dostępna. Podobnie, jeśli nie
chcemy funkcji GNOME w naszych ebuildach, wystarczy upewnić się, że <c>gnome</c>
nie jest dodane do zmiennej <c>USE</c> w pliku <path>/etc/make.conf</path>.
System Gentoo Linux ma niemal przytłaczającą ilość opcji USE, dzięki czemu
możemy skonfigurować go dokładnie tak jak chcemy.
</p>

<note>
Jeśli wyłączymy flagę USE (na przykład usuwając <c>gnome</c> ze zmiennej
<c>USE</c>), poinstruuje to jedynie Portage, aby wyłączyć <e>opcjonalne</e>
wsparcie dla GNOME w czasie budowania. Jednakże jeśli instalujemy za pomocą
narzędzia <c>emerge</c> ebuild, który <e>wymaga</e> GNOME, pakiet ten
oczywiście będzie zawierać obsługę tego środowiska. Oznacza to także, że GNOME
zostanie automatycznie zainstalowane (jako zależność), jeśli wcześniej nie było
go w systemie. Właśnie dlatego dobrze jest użyć polecenia <c>emerge
--pretend</c> zanim uruchomimy "prawdziwy" <c>emerge</c>; w ten
sposób zawsze będziemy wiedzieć co się zainstaluje.
</note>

<p>
W naszych skryptach ebuild możemy sprawdzać czy dana zmienna USE jest ustawiona
za pomocą polecenia <c>use &lt;zmienna&gt;</c>. Najczęściej użyjemy tego
polecenia analogicznie jak poniżej:
</p>

<pre caption="Sprawdzanie czy flaga USE jest ustawiona">
if use X; then
  # Komendy specyficzne dla X...
fi
</pre>

<p>
Zmiennych USE można również używać w celu ustawiania zależności. Na przykład
chcielibyśmy, aby pewien pakiet był wymagany tylko jeśli ustawiona jest pewna
zmienna USE. Możemy tego dokonać za pomocą składni <c>flaga? ( kategoria/pakiet
)</c> w zmiennej <c>DEPEND</c> naszego pliku ebuild. W tym przypadku
<c>kategoria/pakiet</c> będzie wymagana jedynie wtedy, gdy <c>flaga</c> będzie
obecna w zmiennej <c>USE</c>. Możliwe jest także określenie jaka zależność ma
zostać użyta jeśli pewna flaga USE <e>jest</e> ustawiona, a jaka ma zostać
użyta, jeśli <e>nie jest</e> ustawiona: <c>flaga? ( kategoria/pakiet )</c> i
<c>!flaga? ( innakategoria/innypakiet )</c>. W tym przypadku jeśli <c>flaga</c>
nie jest ustawiona, użyta zostanie <c>innakategoria/innypakiet</c> zamiast
<c>kategoria/pakiet</c>. Należy upewnić się, że nasze ebuildy używają powyższej
składni, a nie instrukcji warunkowych IF powłoki bash. Instrukcje warunkowe
basha nie współpracują z cache'owaniem zależności przez Portage, więc używanie
ich popsuje nasz ebuild.
</p>

<p>
Oto ważna wskazówka jak używać zmiennej <c>USE</c>. Najczęściej pakiety
posiadają skrypt <c>./configure</c>, za pomocą którego dokonuje się ich
konfiguracji. Zwykle jeśli nasz ebuild używa <c>./configure</c>, wszelka
opcjonalna funkcjonalność zostanie włączona lub wyłączona przy budowaniu przez
przekazanie odpowiednich parametrów do polecenia <c>./configure</c>. Oto
najlepszy sposób na obsłużenie tego:
</p>

<pre caption="Wyrażenia warunkowe oparte na ustawieniach USE">
DEPEND="X? ( &gt;=x11-base/xfree-4.3 )
mysql? ( &gt;=dev-db/mysql-3.23.49 )
apache2? ( &gt;=net-www/apache-2 )
!apache2? ( =net-www/apache-1* )"

src_compile() {
  econf \
    $(use_enable X x11) \
    $(use_enable mysql) \
    || die "Error: econf failed!"
  emake || die "Error: emake failed!"
}
</pre>

<p>
Takie podejście daje dobre wyniki. Nie musimy martwić się jakie są domyślne
ustawienia mysql albo X (włączone/wyłączone), przekazujemy wprost funkcji
<c>econf</c> co ma zrobić w oparciu o zmienną <c>USE</c>. Nie wspominając już
o przejrzystości takiego kodu. :)
</p>

<p>
Czasami ebuildy będą posiadały konfliktujące opcjonalne funkcjonalności.
Sprawdzanie tych konfliktów oraz drukowanie błędu jeśli
odpowiedź jest twierdząca <e>nie jest</e> dobrym rozwiązaniem. Zamiast tego
należy faworyzować jedną funkcjonalność przed drugą. W takich wypadkach należy
zastanowić się, która opcja dostarcza bardziej powrzechną funkcjonalność, lub
po prostu rzucić monetą.
Przykładem mogą
być ebuildy <c>msmtp</c>. Pakiet ten może współpracować z SSL dostarczanym
przez GnuTLS, z SSL dostarczanym przez OpenSSL lub w ogóle nie posiadać
wsparcia dla SSL. W związku z tym, że GnuTLS posiada szersze możliwości niż
OpenSSL jest faworyzowane, a dokonuje się tego w następujący sposób:
</p>

<pre caption="Uporanie się z konfliktującymi funkcjonalnościami">
src_compile() {
     local myconf

     if use gnutls ; then
         myconf="${myconf} --enable-ssl --with-ssl=gnutls"
     elif use ssl ; then
         myconf="${myconf} --enable-ssl --with-ssl=openssl"
     else
         myconf="${myconf} --disable-ssl"
     fi

     econf \
         # Other stuff
         ${myconf} \
         || die "configure failed"

     emake || die "make failed"
 }
</pre>

<p>
Pod <uri link="/dyn/use-index.xml">tym adresem</uri> możemy obejrzeć stale
uaktualnianą tabelę zmiennych USE.
</p>

</body>
</subsection>
</section>
<section>
<title>Położenia w systemie plików</title>
<subsection>
<title>Wprowadzenie do FHS</title>
<body>

<p>
Standard rozmieszczenia katalogów w systemie plików ściśle odpowiada FHS, czyli
<e>File system Hierarchy Standard</e> (standard hierarchii systemu plików).
Uproszczony opis standardu podajemy poniżej; kompletną specyfikację można
znaleźć pod adresem <uri>http://www.pathname.com/fhs/</uri>.
</p>

<note>
Katalog <path>/opt</path> omówiony jest w części 3.12 standardu FHS. Część 4.4
traktuje o katalogu <path>/usr/X11R6</path>. środowiska KDE i GNOME nie są
omówione, a dokładniej nie ma o nich nawet wzmianki w aktualnej wersji FHS.
</note>

</body>
</subsection>
<subsection>
<title>Jak umieszczać pakiety w systemie plików</title>
<body>

<p>
Jeśli pakiet używa autoconf i automake, domyślne katalogi docelowe przy
instalacji zwykle będą poprawne, z kilkoma wyjątkami:
</p>

<ul>
  <li>
    Jeśli instalujemy program w katalogu <path>/bin</path>, <path>/sbin</path>,
    <path>/usr/bin</path> lub <path>/usr/sbin</path>, dokumentacja man programu
    powinna zostać zainstalowana w katalogu <path>/usr/share/man</path>. Zwykle
    można to osiągnąć pisząc w skrypcie ebuild <c>./configure
    --mandir=/usr/share/man</c>.
  </li>
  <li>
    Pliki dokumentacji GNU info zawsze powinny być instalowane w katalogu
    <path>/usr/share/info</path>, <e>nawet jeśli dokumentacja należy do
    programów specyficznych dla X11, GNOME lub KDE</e>. Zwróćmy uwagę: katalog
    <path>/usr/share/info</path> jest <e>jedynym</e> oficjalnym miejscem na
    pliki GNU info. Często skrypty <c>./configure</c> domyślnie instalują pliki
    GNU info w katalogu <c>/usr/info</c>. W tej sytuacji należy przekazać
    <c>./configure</c> parametr <c>--infodir=/usr/share/info</c>.
  </li>
  <li>
    Pliki dokumentacji są instalowane w katalogu <path>/usr/share/doc</path>,
    do podkatalogu, na którego nazwę składa się nazwa, wersja i rewizja danego
    programu. Dotyczy to wszystkich programów: GNOME, KDE, X11 i konsolowych.
    Niektóre programy jednak mogą dla swoich potrzeb instalować dodatkową
    dokumentację i pliki pomocnicze w hierarchii <path>/usr/share</path>.
  </li>
  <li>
    Programy i biblioteki specyficzne dla X11 zawsze powinny być instalowane w
    katalogu <path>/usr</path>, a nie bezpośrednio w <path>/usr/X11R6</path>.
    Tę hierarchię katalogów rezerwujemy dla <e>samego</e> Systemu X Window w
    Wersji 11, Wydaniu 6. Jest to być może bardziej dosłowna interpretacja
    standardu FHS niż w przypadku wielu innych dystrybucji.
  </li>
  <li>
    Podobnie programy GNOME i KDE powinny być zawsze instalowane w katalogu
    <path>/usr</path>.
  </li>
</ul>

<impo>
Niektóre dystrybucje instalują GNOME i KDE w katalogu <path>/opt</path>. Nie
istnieje standard, który definiowałby gdzie należy umieszczać pliki tych
środowisk graficznych. W imię prostoty i spójności zdecydowaliśmy umieszczać
wszystkie pakiety KDE i GNOME w hierarchii katalogów <path>/usr</path>.
</impo>

<p>
Ogólnie nasze ebuildy powinny instalować pliki w katalogu <path>/usr</path>.
<e>Niektóre</e> programy mogą być kompilowane i linkowane z bibliotekami GNOME,
KDE oraz X11 lub bez nich, co może powodować zamieszanie. Rozwiązanie, jakie
proponujemy to instalowanie wszystkiego w katalogu <path>/usr</path>, dzięki
czemu autorzy skryptów ebuild unikną niejednoznacznych sytuacji i niepotrzebnych
komplikacji. Miejsce, w którym będziemy instalować pliki programu <e>nie
mogą</e> zależeć od obecności lub nieobecności jakichś zmiennych <c>USE</c>.
Dlatego ebuildy w drzewie Portage <e>praktycznie zawsze</e> instalują swoje
pliki wyłącznie w hierarchii katalogów <path>/usr</path>.
</p>

<note>
Katalog <path>/opt</path> jest w systemie Gentoo Linux zarezerwowany dla
pakietów binarnych, na przykład mozilla-bin, acroread, netscape i realplayer.
Najczęściej pakiety instalowane w tym katalogu wymagają dodatkowego pliku
<path>/etc/env.d/coś</path>. Służy on do włączenia ścieżek i dodatkowych
zmiennych do środowiska. Więcej informacji na temat katalogu
<path>/etc/env.d</path> można znaleźć w <uri
link="/doc/pl/handbook/handbook-x86.xml?part=2&amp;chap=5">tym</uri>
dokumencie.
</note>

</body>
</subsection>
</section>
<section>
<title>Skrypty i narzędzia Portage</title>
<subsection>
<title>Skrypty publiczne</title>
<body>

<p>
Są to skrypty używane przez administratora systemu do instalacji i deinstalacji
pakietów, a także przy opiekowaniu się bazą danych pakietów.
</p>

<p>
Skrypt <c>ebuild</c> jest głównym "silnikiem" systemu Portage; za jego pomocą
wykonujemy wszystkie główne zadania, na przykład rozpakowanie, kompilacja,
instalacja, integracja z systemem i deinstalacja pakietów. Używa się go w
następujący sposób: <c>ebuild ścieżka/do/pakiet.ebuild komenda</c>. Oto
dostępne polecenia:
</p>

<table>
<tr>
  <th>Polecenie</th>
  <th>Opis</th>
  <th>Spokrewniona funkcja ze skryptów <c>ebuild</c></th>
</tr>
<tr>
  <ti><c>setup</c>*</ti>
  <ti>
    Wykonuje różnorakie komendy, których uruchomienie wymagane jest zanim
    rozpocznie się właściwe budowanie.
  </ti>
  <ti><c>pkg_setup</c></ti>
</tr>
<tr>
  <ti><c>depend</c></ti>
  <ti>Wyświetla zależności niezbędne do zbudowania pakietu.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>merge</c>*</ti>
  <ti>
    Rozpakowuje, kompiluje, instaluje i integruje pakiet z systemem plików.
  </ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>qmerge</c>*</ti>
  <ti>
    Integruje pakiet z systemem plików, zakładając, że etapy rozpakowania,
    kompilacji i instalacji już zostały wykonane.
  </ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>unpack</c>*</ti>
  <ti>
    Rozpakowuje archiwa z kodem źródłowym w katalogu roboczym.
  </ti>
  <ti><c>src_unpack</c></ti>
</tr>
<tr>
  <ti><c>compile</c>*</ti>
  <ti>Kompiluje pakiet.</ti>
  <ti><c>src_compile</c></ti>
</tr>
<tr>
  <ti><c>rpm</c></ti>
  <ti>Tworzy RPM z pakietu.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>package</c></ti>
  <ti>Tworzy pakiet Gentoo w formacie <c>tbz2</c>.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>prerm</c>*</ti>
  <ti>Wykonuje etap przed usunięciem pakietu.</ti>
  <ti><c>pkg_prerm</c></ti>
</tr>
<tr>
  <ti><c>postrm</c>*</ti>
  <ti>Wykonuje etap po usunięciu pakietu.</ti>
  <ti><c>pkg_postrm</c></ti>
</tr>
<tr>
  <ti><c>preinst</c>*</ti>
  <ti>Wykonuje etap przed zainstalowaniem pakietu.</ti>
  <ti><c>pkg_preinst</c></ti>
</tr>
<tr>
  <ti><c>postinst</c>*</ti>
  <ti>Wykonuje etap po zainstalowaniu pakietu.</ti>
  <ti><c>pkg_postinst</c></ti>
</tr>
<tr>
  <ti><c>config</c></ti>
  <ti>
    Przygotowuje domyślną konfigurację gdy pakiet został zainstalowana w
    systemie plików.
  </ti>
  <ti><c>pkg_config</c></ti>
</tr>
<tr>
  <ti><c>touch</c>*</ti>
  <ti>Uaktualnia czasy modyfikacji każdego archiwum źródłowego pakietu.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>clean</c>*</ti>
  <ti>Czyści katalog roboczy pakietu.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>fetch</c>*</ti>
  <ti>Pobiera pliki ze źródłami pakietu.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>digest</c>*</ti>
  <ti>Tworzy plik digest pakietu.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>test</c>*</ti>
  <ti>Uruchamia funkcję autotestu pakietu.</ti>
  <ti><c>src_test</c></ti>
</tr>
<tr>
  <ti><c>install</c>*</ti>
  <ti>Instaluje pakiet w katalogu obrazu.</ti>
  <ti><c>src_install</c></ti>
</tr>
<tr>
  <ti><c>unmerge</c></ti>
  <ti>Usuwa pakiet z systemu plików.</ti>
  <ti>Nie dotyczy</ti>
</tr>
</table>

<note>
Komendy oznaczone gwiazdką (*) zwykle używane są tylko przez deweloperów.
</note>

<p>
Narzędzie <c>emerge</c> rekursywnie instaluje pakiet i wszystkie jej zależności
w systemie plików. Komenda ta ma wiele opcji, których listę możemy zobaczyć,
wydając polecenie <c>emerge --help</c>.
</p>

<p>
Narzędzie <c>env-update</c> uaktualnia pliki konfiguracyjne (w tym
<path>/etc/ld.so.conf</path> i <path>/etc/profile.env</path>), aby uwzględniały
zmiany wprowadzone przez zainstalowane pakiety.
</p>

</body>
</subsection>
<subsection>
<title>Prywatne skrypty i komendy</title>
<body>

<p>
Skryptów tych możemy użyć w naszych skryptach ebuild do wykonywania typowych
zadań.
</p>

<p>
Jeśli ktoś lubi grzebać w kodzie, może przyjrzeć się poniższym skryptom,
zaglądając do katalogu <path>/usr/lib/portage/bin</path>.
</p>

<table>
<tr>
  <th>Komenda</th>
  <th>Wartość domyślna</th>
  <th>Opis</th>
  <th>Przykład</th>
</tr>
<tr>
  <ti><c>diropts</c></ti>
  <ti>-m0755</ti>
  <ti>Ustawia opcje gdy uruchamiamy skrypt <c>dodir</c>.</ti>
  <ti><c>diropts -m0750</c></ti>
</tr>
<tr>
  <ti><c>dobin</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>Instaluje podane pliki binarne w katalogu <path>DESTTREE/bin</path>.</ti>
  <ti><c>dobin wmacpi</c></ti>
</tr>
<tr>
  <ti><c>docinto</c></ti>
  <ti><path>""</path></ti>
  <ti>
    Ustawia względny podkatalog (<e>DOCDESTTREE</e>) dla skryptu <c>dodoc</c>.
  </ti>
  <ti><c>docinto examples</c></ti>
</tr>
<tr>
  <ti><c>dodir</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>Tworzy katalog, automatycznie uwzględniając katalog ${D}.</ti>
  <ti><c>dodir /usr/lib/newpackage</c></ti>
</tr>
<tr>
  <ti><c>dodoc</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki w katalogu z dokumentacją pakietu
    (<path>/usr/share/doc/${PF}/DOCDESTTREE</path>)  (zob. <c>docinto</c>)
  </ti>
  <ti><c>dodoc README *.txt</c></ti>
</tr>
<tr>
  <ti><c>doexe</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki z uprawnieniami <e>EXEOPTIONS</e> (zob.
    <c>exeopts</c>) w katalogu <path>EXEDESTTREE</path> (zob. <c>exeinto</c>).
  </ti>
  <ti><c>doexe ${FILESDIR}/quake3</c></ti>
</tr>
<tr>
  <ti><c>dohard</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>Tworzy dowiązanie twarde, automatycznie uwzględniając katalog ${D}.</ti>
  <ti><c>dohard ls /bin/dir</c></ti>
</tr>
<tr>
  <ti><c>dohtml</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki i katalogi w katalogu
    <path>/usr/share/doc/${PF}/html</path>.
  </ti>
  <ti><c>dohtml -r doc/html/*</c></ti>
</tr>
<tr>
  <ti><c>doinfo</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki w katalogu /usr/share/info, a następnie kompresuje
    je programem gzip.
  </ti>
  <ti><c>doinfo doc/*.info</c></ti>
</tr>
<tr>
  <ti><c>doins</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki z uprawnieniami <c>INSOPTIONS</c> (zob.
    <c>insopts</c>) w katalogu <path>INSDESTTREE</path> (zob. <c>insinto</c>).
  </ti>
  <ti><c>doins *.png icon.xpm</c></ti>
</tr>
<tr>
  <ti><c>dolib</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane biblioteki w katalogu <path>DESTTREE/lib</path> z
    uprawnieniami 0644.
  </ti>
  <ti><c>dolib *.a *.so</c></ti>
</tr>
<tr>
  <ti><c>dolib.a</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane biblioteki w katalogu <path>DESTTREE/lib</path> z
    uprawnieniami 0644.
  </ti>
  <ti><c>dolib.a *.a</c></ti>
</tr>
<tr>
  <ti><c>dolib.so</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane biblioteki w katalogu <path>DESTTREE/lib</path> z
    uprawnieniami 0644.
  </ti>
  <ti><c>dolib.so *.so</c></ti>
</tr>
<tr>
  <ti><c>doman</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki w katalogu <path>/usr/share/man/manX</path> na
    podstawie przyrostka nazwy pliku (plik.1 zostanie zainstalowany w katalogu
    <path>man1</path>).
  </ti>
  <ti><c>doman *.1 *.5</c></ti>
</tr>
<tr>
  <ti><c>dosbin</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje pliki w katalogu <path>DESTTREE/sbin</path>, upewniając się, że
    uprawnienia zezwalają na ich wykonywanie.
  </ti>
  <ti><c>dosbin ksymoops</c></ti>
</tr>
<tr>
  <ti><c>dosym</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Tworzy dowiązanie symboliczne, automatycznie uwzględniając katalog
    ${D}.
  </ti>
  <ti><c>dosym gzip /bin/zcat</c></ti>
</tr>
<tr>
  <ti><c>emake</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Uruchamia make z argumentami <c>MAKEOPTS</c>. Niektórych pakietów nie można
    kompilować równolegle; wówczas powinniśmy użyć <c>emake -j1</c>. Jeśli
    musimy przekazać jeszcze dodatkowe parametry do make, wystarczy przekazać je
    do polecenia emake jako parametry. Użytkownicy mogą ustawić zmienną
    środowiskową <c>EXTRA_EMAKE</c>, aby przekazywać dodatkowe flagi poleceniu
    emake.
  </ti>
  <ti><c>emake</c></ti>
</tr>
<tr>
  <ti><c>exeinto</c></ti>
  <ti><path>/</path></ti>
  <ti>Ustawia katalog główny (<e>EXEDESTTREE</e>) dla polecenia
  <c>doexe</c>.</ti>
  <ti><c>exeinto /usr/lib/${PN}</c></ti>
</tr>
<tr>
  <ti><c>exeopts</c></ti>
  <ti>-m0755</ti>
  <ti>Ustawia opcje do uruchomienia polecenia <c>doexe</c>.</ti>
  <ti><c>exeopts -m1770</c></ti>
</tr>
<tr>
  <ti><c>fowners</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Nadaje podanemu plikowi podanego właściciela poprzez komendę chown,
    automatycznie uwzględniając katalog ${D}.
  </ti>
  <ti><c>fowners root:root /sbin/functions.sh</c></ti>
</tr>
<tr>
  <ti><c>fperms</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Nadaje podanemu plikowi podane uprawnienia poprzez komendę chmod,
    automatycznie uwzględniając katalog ${D}.
  </ti>
  <ti><c>fperms 700 /var/consoles</c></ti>
</tr>
<tr>
  <ti><c>insinto</c></ti>
  <ti><path>/usr</path></ti>
  <ti>
    Ustawia katalog główny (<e>INSDESTTREE</e>) dla polecenia
    <c>doins</c>.
  </ti>
  <ti><c>insinto /usr/include</c></ti>
</tr>
<tr>
  <ti><c>insopts</c></ti>
  <ti>-m0644</ti>
  <ti>Ustawia opcje do uruchomienia polecenia <c>doins</c>.</ti>
  <ti><c>insopts -m0444</c></ti>
</tr>
<tr>
  <ti><c>into</c></ti>
  <ti><path>/usr</path></ti>
  <ti>
    Ustawia katalog docelowy (<path>DESTTREE</path>) dla wszystkich poleceń
    zaczynających się od 'do' (czyli <c>dobin</c>, <c>dolib</c>, <c>dolib.a</c>,
    <c>dolib.so</c>, <c>domo</c>, <c>dosbin</c>).
  </ti>
  <ti><c>into /</c></ti>
</tr>
<tr>
  <ti><c>libopts</c></ti>
  <ti>-m0644</ti>
  <ti>Ustawia opcje do uruchomienia polecenia <c>dolib</c>.</ti>
  <ti><c>libopts -m0555</c></ti>
</tr>
<tr>
  <ti><c>newbin</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>dobin</c>, instalujący podany plik binarny,
    automatycznie zmieniając jego nazwę na tę podaną w drugim argumencie.
  </ti>
  <ti><c>newbin ${FILESDIR}/vmware.sh vmware</c></ti>
</tr>
<tr>
  <ti><c>newdoc</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>dodoc</c>, instalujący podany plik, automatycznie
    zmieniając jego nazwę na tę podaną w drugim argumencie.
  </ti>
  <ti><c>newdoc README README.opengl</c></ti>
</tr>
<tr>
  <ti><c>newexe</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>doexe</c>, instalujący podany plik, automatycznie
    zmieniając jego nazwę na tę podaną w drugim argumencie.
  </ti>
  <ti><c>newexe ${FILESDIR}/xinetd.rc xinetd</c></ti>
</tr>
<tr>
  <ti><c>newins</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>doins</c>, instalujący podany plik, automatycznie
    zmieniając jego nazwę na tę podaną w drugim argumencie.
  </ti>
  <ti><c>newins ntp.conf.example ntp.conf</c></ti>
</tr>
<tr>
  <ti><c>newman</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>doman</c>, instalujący podany plik, automatycznie
    zmieniając jego nazwę na tę podaną w drugim argumencie.
  </ti>
  <ti><c>newman xboing.man xboing.6</c></ti>
</tr>
<tr>
  <ti><c>newsbin</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>dosbin</c>, instalujący podany plik, automatycznie
    zmieniając jego nazwę na tę podaną w drugim argumencie.
  </ti>
  <ti><c>newsbin strings strings-static</c></ti>
</tr>
<tr>
  <ti><c>prepall</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Uruchamia komendy <c>prepallman</c>, <c>prepallinfo</c>
    i <c>prepallstrip</c>. Upewnia się także, że uprawnienia wszystkich
    bibliotek w katalogach <path>/opt/*/lib</path>, <path>/lib</path>,
    <path>/usr/lib</path> i <path>/usr/X11R6/lib</path> pozwalają na ich
    wykonywanie. Dodatkowo przemieszcza wszelkie zbłąkane makra aclocal do
    katalogu <path>/usr/share/aclocal</path>.
  </ti>
  <ti><c>prepall</c></ti>
</tr>
<tr>
  <ti><c>prepalldocs</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Rekursywnie kompresuje wszystkie pliki dokumentacji z katalogu
    <path>/usr/share/doc</path> za pomocą narzędzia gzip, automatycznie
    poprawiając wszelkie dowiązania symboliczne.
  </ti>
  <ti><c>prepalldocs</c></ti>
</tr>
<tr>
  <ti><c>prepallinfo</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>Rekursywnie kompresuje wszystkie pliki dokumentacji info w katalogu
  <path>/usr/share/info</path>.</ti>
  <ti><c>prepallinfo</c></ti>
</tr>
<tr>
  <ti><c>prepallman</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Rekursywnie kompresuje wszystkie pliki dokumentacji man w katalogach
    <path>/opt/*/man/*</path>, <path>/usr/share/man/*</path>,
    <path>/usr/local/man/*</path>, <path>/usr/X11R6/share/man/*</path>,
    automatycznie poprawiając wszelkie dowiązania symboliczne.
  </ti>
  <ti><c>prepallman</c></ti>
</tr>
</table>

</body>
</subsection>
</section>
<section>
<title>Zależności pakietu</title>
<subsection>
<title>Dlaczego zależności są ważne</title>
<body>

<p>
Portage to coś więcej niż wygodny skrypt pozwalający w ujednolicony sposób
budować oprogramowanie (program, bibliotekę) ze źródeł. Potrafi on także pobrać
i zainstalować wszelkie potrzebne zależności, jeśli tylko podamy je w naszym
skrypcie ebuild.
</p>

<p>
W oficjalnych ebuildach wszystkie zależności zostały już określone, więc gdy
wydamy komendę <c>emerge net-www/mozilla</c>, Portage dopilnuje by wszystkie
zależności niezbędne do zbudowania i uruchomienia Mozilli zostały zainstalowane
zanim zacznie kompilować samą Mozillę.
</p>

<p>
Portage rozróżnia nawet między zależnościami potrzebnymi do zbudowania i do
uruchomienia (Niestety, w tej chwili Portage jedynie instaluje wszystkie
zależności potrzebne do budowania i uruchomienia. W przyszłości jednak będzie
możliwe automatyczne odchudzenie systemu, aby pozostały w nim tylko zależności
potrzebne do uruchamiania programów.
</p>

</body>
</subsection>
<subsection>
<title>
Jak definiować zależności w naszych skryptach ebuild (czyli atomy DEPEND)
</title>
<body>

<p>
Zmienna <c>DEPEND</c> w naszym pliku <path>bla-x.y.z.ebuild</path> mówi Portage
jakie pakiety są potrzebne, aby zbudować program <path>bla</path>. Zmienna
<c>RDEPEND</c> określa zaś jakie pakiety są potrzebne, aby uruchomić
<path>bla</path>. Zmienna <c>RDEPEND</c> powinna być ustawiona jawnie, nawet
jeśli jej wartość jest taka sama jak w przypadku <c>DEPEND</c>, ponieważ w
przyszłości zmiennej <c>RDEPEND</c> nie będzie domyślnie przypisywana wartość
<c>DEPEND</c>, w przypadku braku zdefiniowania tej pierwszej.
</p>

<pre caption="Przykład zależności">
DEPEND="virtual/libc
        sys-libs/zlib"
RDEPEND="virtual/libc"
</pre>

<p>
Ten przykład informuje Portage o fakcie, że aby zbudować pakiet
<path>bla-x.y.z</path> potrzebne będą pakiety <path>virtual/libc</path> (więcej
o kategoriach wirtualnych wkrótce) i <path>sys-libs/zlib</path>. Nie jest
podane jakie wersje glibc i zlib są potrzebne, co oznacza, że dobre będą
wszystkie.
</p>

<p>
Rzecz jasna, "dobre będą wszystkie" w większości wypadków nie wystarczy.
Jedynie w przypadku głównych bibliotek takich jak glibc jest to wystarczające,
ponieważ jego autorzy bardzo się starają, aby był on zawsze w stu procentach
binarnie kompatybilny. W przypadku innych bibliotek możemy oczywiście podać
wersje zależności.
</p>

<pre caption="Przykład wersji">
&gt;=sys-apps/bar-1.2
=sys-apps/baz-1.0
</pre>

<p>
Znaki &gt;= i = oznaczają to, czego możemy się po nich spodziewać; wersja 1.2
lub nowsza programu sys-apps/bar będzie się nadawać (oznacza to, że również
wersja 2.0 sys-apps/bar też będzie odpowiednia), zaś wersja 1.0 programu
sys-apps/baz będzie jedyną odpowiednią. Więcej informacji na temat wzorca wersji
pakietów można znaleźć wyżej w rozdziale <uri
link="#doc_chap2_sect2">Nazewnictwo plików ebuild</uri>.
</p>

<p>
Oto inne sposoby na podawanie wersji zależności:
</p>

<pre caption="Podawanie wersji zależności">
~sys-apps/qux-1.0
=sys-apps/bla-1.2*
!sys-libs/gdbm
</pre>

<p>
~sys-apps/qux-1.0 wybierze najnowszą rewizję programu qux-1.0 w Portage.
</p>

<p>
=sys-apps/bla-1.2* wybierze najnowsze wersje spośród gałęzi 1.2, ale zignoruje
1.3 i wcześniejsze/późniejsze gałęzie. Tak więc bla-1.2.3 i bla-1.2.0 będą
odpowiednie, zaś bla-1.3.3, bla-1.3.0 i bla-1.1.0 już nie.
</p>

<p>
!sys-libs/gdbm uniemożliwi instalację tego pakietu jeśli gdbm jest
zainstalowane.
</p>

</body>
</subsection>
<subsection>
<title>Ważne uwagi</title>
<body>

<p>
Przy konfiguracji zmiennych DEPEND i RDEPEND można popełnić wiele błędów. Oto
kilka porad, dzięki którym możemy ich uniknąć.
</p>

<ul>
  <li>
    <e>Zawsze należy podać kategorię.</e><br />
    Na przykład powinniśmy napisać <c>&gt;=x11-libs/gtk+-2</c> zamiast tylko
    <c>&gt;=gtk+-2</c>.
  </li>
  <li>
    <e>Nie powinniśmy stawiać znaku gwiazdki (*) przy zależnościach typu
    &gt;=.</e><br />
    Prawidłowo powinniśmy napisać <c>&gt;=x11-libs/gtk+-2</c> zamiast
    <c>&gt;=x11-libs/gtk+-2*</c>.
  </li>
  <li>
    <e>Nie wolno definiować meta-pakietu jako zależności.</e><br />
    Nie powinniśmy więc określić zależności od gnome-base/gnome, zamiast tego
    używamy konkretnej biblioteki, na przykład libgnome.
  </li>
  <li>
    <e>Podajemy jedną zależność na linię.</e><br />
    Definiowanie więcej niż jednej zależności w jednej linii sprawia, że kod
    jest brzydki i trudny do zrozumienia.
  </li>
  <li>
    <e>GTK: Zawsze należy użyć zależności =x11-libs/gtk+-1.2* przy aplikacjach
    GTK+1.</e>
  </li>
</ul>

<p>
Ponadto powinniśmy się upewnić, że podaliśmy wszystkie zależności naszego
pakietu:
</p>

<ul>
  <li>
    <e>Zajrzyjmy do plików configure.in lub configure.ac</e><br />
    Poszukajmy w nich sprawdzania obecności pakietów. Warto zwrócić uwagę na
    sprawdzenia pkg-config lub funkcje AM_*, które szukają konkretnej wersji.
  </li>
  <li>
    <e>Możemy przyjrzeć się dołączonym plikom .spec</e><br />
    Zwykle dołączone pliki .spec mogą być źródłem informacji o zależnościach.
    Nie należy jednak traktować ich jako jedynego źródła.
  </li>
  <li>
    <e>Poszukajmy strony internetowej aplikacji/biblioteki</e><br />
    Autor często sugeruje na oficjalnej stronie jakich zależności wymaga jego
    program.
  </li>
  <li>
    <e>Warto przeczytać pliki README i INSTALL dołączone do pakietu</e><br />
    Zwykle zawierają one informacje przydatne przy budowaniu i instalowaniu
    pakietów.
  </li>
  <li>
    <e>Należy pamiętać o zależnościach innych niż binarne, takie jak pkg-config,
    programy do generowania dokumentacji, itd.</e><br />
    Proces budowania zwykle wymaga zależności takich jak intltool, libtool,
    pkg-config, doxygen, scrollkeeper, gtk-doc itp. Upewnijmy się, że zostały
    one podane.
  </li>
</ul>

<p>
Aby zapoznać się z najnowszymi informacjami o atomach DEPEND, należy przeczytać
5 sekcję dokumentacji systemowej man: <c>man 5 ebuild</c>.
</p>

</body>
</subsection>
</section>
<section>
<title>Testowanie i wdrożenie</title>
<subsection>
<title>Plik ChangeLog</title>
<body>

<p>
Za każdym razem gdy uaktualniamy (lub piszemy nowy) skrypt ebuild, musimy także
uaktualnić (lub utworzyć) jego Changelog. Plik <path>skel.ChangeLog</path>
zawiera przykładową treść i może zostać potraktowany jako wzór.
</p>

<p>
Funkcją pliku Changelog jest udokumentowanie <e>co</e> zostało zrobione,
<e>czemu</e> zostało to zrobione i <e>kto</e> tego dokonał. Dzięki temu zarówno
deweloperzy jak i użytkownicy mogą w łatwy sposób prześledzić zmiany.
</p>

<p>
Changelog jest głównie przeznaczony dla użytkowników, należy więc pisać krótko,
na temat i unikać zbędnych technicznych szczegółów.
</p>

</body>
</subsection>
<subsection>
<title>Przechowywanie plików ebuild lokalnie</title>
<body>

<p>
Aby możliwe było testowanie skryptów ebuild oraz poinformowanie Portage o ich
istnieniu, musimy umieścić je w określonym katalogu. Portage używa w tym celu
zmiennej <c>PORTDIR_OVERLAY</c>, definiowanej przez użytkownika w pliku
<path>/etc/make.conf</path>. Powinniśmy użyć tej zmiennej aby podać katalog, w
którym będziemy trzymać nasze ebuildy (może to być na przykład
<path>/usr/local/portage</path>).
</p>

<p>
W katalogu tym należy używać tej samej struktury (i tych samych kategorii) co w
katalogu <path>/usr/portage</path>.
</p>

<p>
Gdy używamy <c>PORTDIR_OVERLAY</c> nasze ebuildy pozostaną w systemie i będą
wciąż rozpoznawane przez Portage nawet gdy wykonamy polecenie
<c>emerge sync</c>.
</p>

</body>
</subsection>

<subsection>
<title>Testowanie pakietów</title>
<body>

<p>
Zastanówmy się w jaki sposób przetestować czy nasz pakiet działa. Czasem
deweloperzy od razu dołączyli polecenia <c>make test</c> lub <c>make check</c>,
które sprawdzą podstawowe funkcje pakietu. Jeśli tak, to uruchomienie <c>env
FEATURES=test ebuild <path>bla-x.y.z.ebuild</path> test</c> wykona je.
Jeśli polecenia te nie działają poprawnie, spróbujmy je naprawić (i wysłać
łatki autorom programu).
</p>

<p>
Jeśli takich poleceń nie ma, należy rozważyć dodanie funkcji <c>src_test</c>  do
naszego skryptu ebuild. Jest ona wykonywana przed funkcją <c>src_install</c> i
może być bardzo pomocna przy testowaniu działania programu na różnych
architekturach. Deweloperzy innych architektur będą nam wdzięczni jeśli dodamy
tę funkcję, dzięki czemu nie będą musieli zagłębiać się w funkcjonowanie
pakietu.
</p>

<p>
Należy jednak pamiętać o ogólnej zasadzie działania plików ebuild. Funkcja
<c>src_test</c> nie może być interaktywna. Jeśli wymaga ona innych pakietów,
należy użyć flagi USE <c>test</c> w celu podania dodatkowych zależności
kompilacji w zmiennej <c>DEPEND</c>. Weźmy też pod uwagę, że funkcje
<c>src_test</c> nie są zalecane przy graficznych aplikacjach korzystających z X,
ponieważ użytkownik korzystający z Portage niekoniecznie będzie miał możliwość
uruchomienia ich.
</p>

</body>
</subsection>
<subsection>
<title>Przydatne narzędzia testujące</title>
<body>

<p>
Istnieje kilka przydatnych narzędzi, które pomogą nam w pisaniu i opiekowaniu
się naszymi ebuildami.
</p>

<table>
<tr>
  <th>Narzędzie</th>
  <th>Pakiet</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><c>repoman</c></ti>
  <ti>sys-apps/portage</ti>
  <ti>
    Narzędzie tylko dla deweloperów, wspomagające funkcję checkin z CVS.
    Wykonuje ona wiele typowych zadań QA (zapewniania jakości) i upewnia się, że
    dodawane do CVS pliki nie uszkodzą drzewa Portage.
  </ti>
</tr>
<tr>
  <ti><c>ccache</c></ti>
  <ti>dev-util/ccache</ti>
  <ti>
    Narzędzie to zachowuje przetworzone pliki robocze, aby <e>znacznie</e>
    przyspieszyć kompilację. Pamiętajmy, aby dodać <c>ccache</c> do zmiennej
    <c>FEATURES</c> w pliku <path>/etc/make.conf</path>!
  </ti>
</tr>
<tr>
  <ti><c>sandboxshell</c></ti>
  <ti>app-shells/sandboxshell</ti>
  <ti>
    Uruchamia powłokę, która tworzy środowisko sandbox. Przydatne jeśli chcemy
    dostać się do tego samego środowiska, w którym Portage buduje pakiety, a
    także jeśli chcemy coś ręcznie debugować.
  </ti>
</tr>
<tr>
  <ti><c>echangelog</c></ti>
  <ti>app-portage/gentoolkit-dev</ti>
  <ti>
    Może utworzyć nowy plik Changelog lub dodać wpis do już istniejącego pliku.
  </ti>
</tr>
</table>

</body>
</subsection>
</section>
</sections>
