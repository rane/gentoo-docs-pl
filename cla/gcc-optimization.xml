<?xml version='1.0' encoding='UTF-8'?>

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/en/co-guide.xml,v 1.1 2007/06/27 06:04:17 nightmorph Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/en/co-guide.xml" lang="pl">

<title>Przewodnik po optymalizacji</title>

<author title="Autor">
  <mail link="nightmorph@gentoo.org">Joshua Saddler</mail>
</author>
<author title="Tłumacz">
  <mail link="cla@gentoo.org">Dawid Węgliński</mail>
</author>

<abstract>
Ten przewodnik jest wstępem do optymalizacji kompilowanego kodu, przy użyciu
bezpiecznych, rozsądnych CFLAGS oraz CXXFLAGS. Opisuje również teorię
optymalizacji.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.0</version>
<date>2007-06-26</date>

<chapter>
<title>Wstęp</title>
<section>
<title>Czym są CFLAGS i CXXFLAGS?</title>
<body>

<p>
CFLAGS i CXXFLAGS są zmiennymi środowiskowymi, które są używane przy kompilacji
kodu przez kompilator <c>gcc</c>. Mówią one jakie przełączniki mają być użyte
podczas kompilaci. Zmienna CFLAGS jest dla kodu napisanego w języku C, zaś
CXXFLAS dla kodu napisanego w C++.
</p>

<p>
Mogą one się przysłużyć do zmniejszenia się ilości informacji diagnostycznych
dla programu, wzrostu poziomu ostrzeżeniach o błędach i optymalizacji
wyprodukowanego kodu. <uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Invoking-GCC.html#Invoking-GCC">Podręcznik
GNU gcc</uri> zawiera kompletną listę z dostępnymi opcjami i opisem ich
działania.
</p>

</body>
</section>
<section>
<title>Jak ich używać?</title>
<body>

<p>
CFLAGS i CXXFLAGS mogą być użyte na dwa sposoby. Po pierwsze, mogą być użyte
przez bezpośrednie wywołanie programu <c>gcc</c> oraz kod, który ma zostać
skompilowany.
</p>

<pre caption="Bezpośrednie wywołanie">
$ <i>CFLAGS="-march=i686" gcc file.c</i>
</pre>

<p>
Nie powinno się tego używać podczas instalacji pakietów z drzewa Portage. Od
tego są zmienne CFLAGS i CXXFLAGS w <path>/etc/make.conf</path>. Tą drogą
wszystkie pakiety zostaną skompilowane z danymi opcjami.
</p>

<pre caption="CFLAGS w /etc/make.conf">
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
</pre>

<p>
Jak można dostrzec, CXXFLAGS zawiera wszystkie opcje podane przez CFLAGS. Jest
to bezpieczny sposób, który nigdy nie powinien zawieść. Nigdy nie powinno się
dodawać innych opcji do CXXFLAGS.
</p>

<impo>
Portage nie może użyć CFLAGS na podstawie pakietu, który ma kompilować. Nie ma
też dostępnej metody, która mogła by to wymusić. Flagi, które są ustawione w
<path>/etc/make.conf</path> zostaną użyte dla <e>wszystkich</e> instalowanych
pakietów.
</impo>

</body>
</section>
<section>
<title>Błędne mniemanie</title>
<body>

<p>
Kiedy mówi się, że CFLAGS i CXXFLAGS mogą być bardzo efektywne, znaczy to, że
produkuje mniejszą i/lub szybszą wersję binarną. Mogą również osłabić funkcje
kodu oraz powiększyć jego rozmiary, spowolnić czas jego wykonywania a nawet
spowodować niepowodzenie jego kompilacji!
</p>

<p>
CFLAGS nie jest receptą na sukces. Nie stworzą systemu, który będzie się
uruchamiał szybciej lub też skompilowany kod będzie zabierał mniej miejsca.
Dodawanie większej ilości flag w celu optymalizacji zaskutkuje wprost
przeciwnie. Jest to pewna recepta na niepowodzenie.
</p>

<p>
Pomimo pochwał, można znaleźć w internecie informacje o tym, że agresywne
flagi mogą wyrządzić więcej szkód w systemie niż pożytku. Należy pamiętać o tym,
że powodem istnienia flag jest określony cel działania. To, że poszczególne
opcje są dobre dla kawałka kodu, nie oznacza, że są dobre dla wszystkiego, co
będzie instalowane w systemie!
</p>

</body>
</section>
<section>
<title>Gotowy?</title>
<body>

<p>
Skoro już jesteśmy świadomi ryzyka, spójrzmy na kilka bezpiecznych flag dla
naszego systemu. Pozwoli to być pożytecznym zawsze, kiedy zostanie zgłoszony
problem na <uri link="http://bugs.gentoo.org">Bugzilli</uri>. Deweloperzy zwykle
proszą o ponowną kompilację kodu z minimalnymi flagami, aby dowiedzieć się, czy
problem faktycznie istnieje. Ważne jest to, że agresywne flagi mogą zrujnować
kod.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Optymalizacja</title>
<section>
<title>Podstawy</title>
<body>

<p>
Celem flag jest stworzenie kodu, idealnie dopasowanego do konfiguracji
sprzętowej; powinien działać prawidłowo, a zarazem być mały i szybki jak tylko
możliwe. Czasami te dwie cechy się wzajemnie wykluczają, więc trzeba trochę
poeksperymentować z takimi kombinacjami, jakie będą prawidłowe. Są one dostępne
dla każdej architekstury procesora. Agresywne flagi zostaną wspomiane w
późniejszym etapie. Nie omówimy każdej opcji z podręcznika <c>gcc</c>, ponieważ
jest ich setki. Skupimy się na głównych, najczęściej używanych flagach.
</p>

<note>
Nie będąc pewnym do czego służy dana flaga, należy odwołać się do odpowiedniej
sekcji <uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Optimize-Options.html#Optimize-Options">Podręcznika
gcc</uri>. W razie dalszych wątpliwości można również sprawdzić <uri
link="http://gcc.gnu.org/lists.html">listę mailingową</uri> <c>gcc</c>.
</note>

</body>
</section>
<section>
<title>-march</title>
<body>

<p>
Najważniejszą opcją jest <c>-march</c>. Mówi ona kompilatorowi jaki powinien być
kod wynikowy dla używanej <uri
link="http://en.wikipedia.org/wiki/Microarchitecture">architektury</uri>
(<e>arch</e>) procesora. Różne rodzaje procesorów mają różne zdolności,
wspierają różne instrukcje i mają różne rodzaje wykonywania kodu. Flaga
<c>-march</c> ma za zadanie stworzenie kodu, który będzie specyficzny dla danego
procesora, ze wszystkimi tymi zdolnościami, cechami, instrukcjami itp.
</p>

<p>
Nawet jeśli zmienna CHOST jest ustawiona w pliku <path>/etc/make.conf</path> i
określa używaną architekturę, flaga <c>-march</c> powinna być użyta aby programy
mogły zostać zoptymalizowane dla konkretnego procesora.
</p>

<p>
Aby dowiedzieć się, jaki rodzaj procesora jest w komputerze, którego używamy,
należy wykonać polecenie:
</p>

<pre caption="Analiza informacji o procesorze">
$ <i>cat /proc/cpuinfo</i>
</pre>

<p>
Oglądnijmy <c>-march</c> w akcji. Ten przykład jest dla starszego procesora
Pentium III:
</p>

<pre caption="/etc/make.conf: Pentium III">
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
</pre>

<p>
Ten przykład pochodzi z 64-bitowego procesora Sparc.
</p>

<pre caption="/etc/make.conf: Sparc">
CFLAGS="-march=ultrasparc"
CXXFLAGS="${CFLAGS}"
</pre>


<p>
Dostępne są również flagi <c>-mcpu</c> oraz <c>-mtune</c>. Jednak powinny zostać
one użyte tylko wtedy, gdy opcja <c>-march</c> nie jest dostępna. Jaka jest
między nimi różnica? <c>-march</c> dokładniej precyzuje jakie cechy powinny
zostać użyte podczas kompilacji kodu. <c>-mcpu</c> stworzy ogólny kod, mało
zoptymalizowany dla naszego procesora. <c>-mtune</c> tworzy kod jeszcze bardziej
ogólny. Należy użyć <c>-march</c> zawsze kiedy jest dostępny. Dla architektur
takich jak PowerPC lub Alpha musi zostać użyty <c>-mcpu</c>.
</p>

<note>
Dla konkretniejszych ustawień <c>-march</c> należy przeczytać rozdział piąty
<uri link="/doc/en/handbook/index.xml">Podręcznika instalacji Gentoo</uri> dla
odpowiedniej architektury. Polecamy również przeczytać listę podręcznika
<c>gcc</c> o <uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Submodel-Options.html#Submodel-Options">opcjach
specyficznych dla danej architektury</uri> gdzie jest dokładnie wytłumaczona
różnica pomiędzy <c>-march</c>, <c>-mcpu</c> i <c>-mtune</c>. Jest to bardzo
pomocne przy precyzowaniu jakie opcje <c>-march</c> powinny zostać użyte.
Zwłaszcza, że na niektórych architekturach, takich jak x86 flaga <c>-mcpu</c>
jest przestarzała i niepolecana i powinno się użyć <c>-mtune</c> zamiast niej.
</note>

</body>
</section>
<section>
<title>-O</title>
<body>

<p>
Następną opcją jest <c>-O</c>. Kontroluje ona całkowity poziom optymalizacji.
Może ona spowodować, że kod będzie się kompilował nieco dłużej i zostanie użyte
nieco więcej pamięci wraz z jej podnoszeniem.
</p>

<p>
Jest pięć opcji: <c>-O0</c>, <c>-O1</c>, <c>-O2</c>, <c>-O3</c> oraz <c>-Os</c>.
W <path>/etc/make.conf</path> powinna być użyta tylko jedna.
</p>

<p>
Z wyjątkiem <c>-O0</c>, każda następna opcja aktywuje kilka dodatkowych flag.
O tym jakie są to flagi i co powodują  można sie dowiedzieć po przeczytaniu
rozdziału o <uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Optimize-Options.html#Optimize-Options">opcjach
optymalizacji</uri> strony manuala gcc.
</p>

<p>
Przeanalizujmy każdy poziom optymalizacji:
</p>

<ul>
  <li>
    <c>-O0</c>: Ten poziom (jest to litera "O" za którą jest cyfra zero)
    kompletnie wyłącza optymalizację i jest domyślna kiedy opcja <c>-O</c> nie
    jest określona w zmiennych CFLAGS i CXXFLAGS, co nie jest generalnie
    pożądane.
  </li>
  <li>
    <c>-O1</c>: Bardzi podstawowy poziom optymalizacji. Kompilator będzie
    próbował budować szybszy i mniejszy kod bez tracenia na to czasu. Jest to
    naprawdę podstawowy poziom ale nie powinien stanowić problemów podczas
    kompilacji.
  </li>
  <li>
    <c>-O2</c>: Poziom wyżej od <c>-O1</c>. Jest to <e>zalecany</c> poziom
    optymalizacji jeżeli nie mamy specialnych potrzeb (takich jak <c>-Os</c>, co
    zostanie wyjaśnione wkrótce). <c>-O2</c> do <c>-O1</c> doda kilka nowych
    flag. Z tą opcją kompilator będzie próbował zwiększyć wydajność kodu nie
    zwracając uwagi na rozmiar kodu wynikowego przy długim czasie kompilacji.
  </li>
  <li>
    <c>-O3</c>: Najwyższy możliwy poziom optymalizacji i zarazem najbardziej
    ryzykowny. Z tą opcję kompilator będzie tracił dużo czasu na stworzenie kodu
    wynikowego. Generalnie opcja <e>nie powinna być używana na systemach
    używających <c>gcc</c> w wersji 4.x</e>. Zachowanie <c>gcc</c> znacznie się
    zmieniło od wersji 3.x, gdzie opcja <c>-O3</c> miała prowadzić do trochę
    szybszego wykonania niż przy <c>-O2</c>. Przy wersji kompilatora <c>gcc</c>
    4.x, kod <e>będzie</e> wynikował wielkim rozmiarem i dużą ilością pamięci.
    Będzie również znacznie zwiększał przypadki niepowodzenia kompilacji i
    nieoczekiwane zachowanie programów, a to przeważa nad pożytkiem. <b>Używanie
    <c>-O3</c> nie jest zalecane dla <c>gcc</c> 4.x.</b>
  </li>
  <li>
    <c>-Os</c>: Ten poziom będzie optymalizował kod pod względem wielkości.
    Aktywuje on wszystkie flagi z poziomu <c>-O2</c>, które nie biorą udziału w
    zwiększeniu wygenerowanego kodu. Jest to przydatne dla maszyn, które mają
    bardzo ograniczoną przestrzeń dyskową lub z procesorami o bardzo małej
    wielkości cache.
  </li>
</ul>

<p>
Jak zostało wcześniej wspomniane, <c>-O2</c> jest rekomendowanym poziomem
optymalizacji. Jeśli pakiet zawiedzie podczas kompilacji, należy się upewnić, że
nie jest używana opcja <c>-O3</c>. Należy wtedy spróbować z niższym poziomem
optymalizacji, takim jak <c>-O1</c> lub <c>-Os</c>.
</p>

</body>
</section>
<section>
<title>-pipe</title>
<body>

<p>
<c>-pipe</c> jest bezpieczną flagą. Nie ma ona wpływu na generowany kod, lecz
przynosi zysk w prędkości kompilacji. Każe kompilatorowi używać potoków zamiast
plików tymczasowych w różnych etapach kompilacji.
</p>

</body>
</section>
<section>
<title>-fomit-frame-pointer</title>
<body>

<p>
This is a very common flag designed to reduce generated code size. It is turned
on at all levels of <c>-O</c> (except <c>-O0</c>) on architectures where doing
so does not interfere with debugging (such as x86-64), but you may need to
activate it yourself by adding it to your flags. Though the GNU <c>gcc</c>
manual does not specify all architectures it is turned on by using <c>-O</c>,
you will need to explicity activate it on x86. However, using this flag will
make debugging hard to impossible.
</p>

<p>
In particular, it makes troubleshooting applications written in Java much
harder, though Java is not the only code affected by using this flag. So while
the flag can help, it can also make debugging harder. If you don't plan to do
much debugging and haven't added any other debugging-related CFLAGS such as
<c>-ggdb</c> (and you aren't installing packages with the <c>debug</c> USE
flag), then try using <c>-fomit-frame-pointer</c>.
</p>

<impo>
Do <e>not</e> combine <c>-fomit-frame-pointer</c> with the similar flag
<c>-momit-leaf-frame-pointer</c>. Using the latter flag is discouraged, as
<c>-fomit-frame-pointer</c> already does the job properly. Furthermore,
<c>-momit-leaf-frame-pointer</c> has been shown to negatively impact code
performance.
<!--
source for this info:
http://www.coyotegulch.com/products/acovea/aco5p4gcc40.html
-->
</impo>

</body>
</section>
<section>
<title>-msse, -msse2, -msse3, -mmmx, -m3dnow</title>
<body>

<p>
These flags enable the <uri
link="http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</uri>, <uri
link="http://en.wikipedia.org/wiki/SSE2">SSE2</uri>, <uri
link="http://en.wikipedia.org/wiki/SSSE3">SSE3</uri>, <uri
link="http://en.wikipedia.org/wiki/MMX">MMX</uri>, and <uri
link="http://en.wikipedia.org/wiki/3dnow">3DNow!</uri> instruction sets for x86
and x86-64 architectures. These are useful primarily in multimedia, gaming, and
other floating point-intensive computing tasks, though they also contain several
other mathematical enhancements. These instruction sets are found in more modern
CPUs.
</p>

<impo>
Be sure to check if your CPU supports these by running <c>cat /proc/cpuinfo</c>.
The output will include any supported additional instruction sets. Note that
<b>pni</b> is just a different name for SSE3.
</impo>

<p>
You normally don't need to add any of these flags to <path>/etc/make.conf</path>
as long as you are using the correct <c>-march</c> (for example,
<c>-march=nocona</c> implies <c>-msse3</c>). Some notable exceptions are newer
VIA and AMD64 CPUs that support instructions not implied by <c>-march</c> (such
as SSE3). For CPUs like these you'll need to enable additional flags where
appropriate after checking the output of <c>cat /proc/cpuinfo</c>.
</p>

<note>
You should check the <uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options">list</uri>
of x86 and x86-64-specific flags to see which of these instruction sets are
activated by the proper CPU type flag. If an instruction is listed, then you
don't need to specify it; it will be turned on by using the proper <c>-march</c>
setting.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Optimization FAQs</title>
<section>
<title>But I get better performance with -funroll-loops -fomg-optimize!</title>
<body>

<p>
No, you only <e>think</e> you do because someone has convinced you that more
flags are better. Aggressive flags will only hurt your applications when used
system-wide. Even the <c>gcc</c> <uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Optimize-Options.html#Optimize-Options">manual</uri>
says that using <c>-funroll-loops</c> and <c>-funroll-all-loops</c> makes code
larger and run more slowly. Yet for some reason, these two flags, along with
<c>-ffast-math</c>, <c>-fforce-mem</c>, <c>-fforce-addr</c>, and similar flags,
continue to be very popular among ricers who want the biggest bragging rights.
</p>

<p>
The truth of the matter is that they are dangerously aggressive flags. Take a
good look around the <uri link="http://forums.gentoo.org">Gentoo Forums</uri>
and <uri link="http://bugs.gentoo.org">Bugzilla</uri> to see what those flags
do: nothing good!
</p>

<p>
You don't need to use those flags globally in CFLAGS or CXXFLAGS. They will only
hurt performance. They may make you sound like you have a high-performance
system running on the bleeding edge, but they don't do anything but bloat your
code and get your bugs marked INVALID or WONTFIX.
</p>

<p>
You don't need dangerous flags like these. <b>Don't use them</b>. Stick to the
basics: <c>-march</c>, <c>-O</c>, and <c>-pipe</c>.
</p>

</body>
</section>
<section>
<title>What about -O levels higher than 3?</title>
<body>

<p>
Some users boast about even better performance obtained by using <c>-O4</c>,
<c>-O9</c>, and so on, but the reality is that <c>-O</c> levels higher than 3
have no effect. The compiler may accept CFLAGS like <c>-O4</c>, but it actually
doesn't do anything with them. It only performs the optimizations for
<c>-O3</c>, nothing more.
</p>

<p>
Need more proof? Examine the <c>gcc</c> <uri
link="http://gcc.gnu.org/viewcvs/trunk/gcc/opts.c?revision=124622&amp;view=markup">source
code</uri>:
</p>

<pre caption="-O source code">
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
</pre>

<p>
As you can see, any value higher than 3 is treated as just <c>-O3</c>.
</p>

</body>
</section>
<section>
<title>What about redundant flags?</title>
<body>

<p>
Oftentimes CFLAGS and CXXFLAGS that are turned on at various <c>-O</c> levels
are specified redundantly in <path>/etc/make.conf</path>. Sometimes this is done
out of ignorance, but it is also done to avoid flag filtering or flag replacing.
</p>

<p>
Flag filtering/replacing is done in many of the ebuilds in the Portage tree. It
is usually done because packages fail to compile at certain <c>-O</c> levels, or
when the source code is too sensitive for any additional flags to be used. The
ebuild will either filter out some or all CFLAGS and CXXFLAGS, or it may replace
<c>-O</c> with a different level.
</p>

<p>
The <uri
link="http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html">Gentoo
Developer Manual</uri> outlines where and how flag filtering/replacing works.
</p>

<p>
It's possible to circumvent <c>-O</c> filtering by redundantly listing the flags
for a certain level, such as <c>-O3</c>, by doing things like:
</p>

<pre caption="Specifying redundant CFLAGS">
CFLAGS="-O3 -finline-functions -funswitch-loops"
</pre>

<p>
However, <brite>this is not a smart thing to do</brite>. CFLAGS are filtered for
a reason! When flags are filtered, it means that it is unsafe to build a package
with those flags. Clearly, it is <e>not</e> safe to compile your whole system
with <c>-O3</c> if some of the flags turned on by that level will cause problems
with certain packages. Therefore, you shouldn't try to "outsmart" the developers
who maintain those packages. <e>Trust the developers</e>. Flag filtering and
replacing is done for your benefit! If an ebuild specifies alternative flags,
then don't try to get around it.
</p>

<p>
You will most likely continue to run into problems when you build a package with
unacceptable flags. When you report your troubles on Bugzilla, the flags you use
in <path>/etc/make.conf</path> will be readily visible and you will be told to
recompile without those flags. Save yourself the trouble of recompiling by not
using redundant flags in the first place! Don't just automatically assume that
you know better than the developers.
</p>

</body>
</section>
<section>
<title>What about LDFLAGS?</title>
<body>

<p>
Don't use them. You may have heard that they can speed up application load times
or reduce binary size, but in reality, LDFLAGS are more likely to make your
applications stop working. They are not supported, and you can expect to have
your bugs closed and marked INVALID if you report errors with packages while
using LDFLAGS. At the very least you will have to recompile all affected
packages without setting LDFLAGS.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Resources</title>
<section>
<body>

<p>
The following resources are of some help in further understanding optimization:
</p>

<ul>
  <li>
    The <uri link="http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/">GNU gcc
    manual</uri>
  </li>
  <li>
    Chapter 5 of the <uri link="/doc/en/handbook/">Gentoo Installation
    Handbooks</uri>
  </li>
  <li><c>man make.conf</c></li>
  <li><uri link="http://en.wikipedia.org">Wikipedia</uri></li>
  <li>
    <uri link="http://www.coyotegulch.com/products/acovea/">Acovea</uri>, a
    benchmarking and test suite that can be useful for determining how different
    compiler flags interact and affect generated code, though its code
    suggestions are not appropriate for system-wide use. It is available in
    Portage: <c>emerge acovea</c>.
  </li>
  <li>The <uri link="http://forums.gentoo.org">Gentoo Forums</uri></li>
</ul>

</body>
</section>
</chapter>
</guide>
